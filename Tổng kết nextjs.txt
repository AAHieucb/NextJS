# Basic
-> Server sẽ chạy qua mọi component 1 lần để build html với dữ liệu có thể từ getServerSideProps, gửi cho client sẽ chạy useEffect tiếp. 
VD console.log trong component mà ngoài useEffect sẽ hiện ở console của server, k dùng được localStorage hay window ở ngoài.
Có thể tạo constructor cho functional component như class component để setup các thứ ngay tại server khi chạy qua lần đầu tiên với hook useConstructor. Dùng useMemo với dependencies trống [] thì sẽ chạy ở client trước khi render DOM như constructor.

-> npm run build + npm run start => build từng page dạng HTML và lệnh start sẽ chạy 1 server nodejs serve các file đó là SSR
npm run build + npm run export => build từng page và xuất đống đó thành html tĩnh, có thể host lên thành static web.

"next dev --turbo" dùng turbopack nhanh hơn bth

-> Thêm font: Có thể thêm font bằng CDN thẻ link từng pages
Dùng next/font => ưu tiên
Dùng next/font/local => định nghĩa local font bằng js

-> Favicon hay các icon khác cũng có convention về file: https://nextjs.org/docs/app/api-reference/file-conventions/metadata/app-icons

-> npx create-next-app -e with-tailwindcss test-nextjs => có nhiều loại example template kết hợp đủ loại thư viện

-> Có thể check kiểu chạy trong file config:
import { PHASE_DEVELOPMENT_SERVER } from 'next/constants.js'
export default (phase) => {
  const isDev = phase === PHASE_DEVELOPMENT_SERVER
  const nextConfig = {};
  return nextConfig
} => npm run dev thì isDev mới = true, k check được trong component

-> Partial rendering: https://www.youtube.com/watch?v=MTcPrTIBkpA
Các component dùng cookies hay searchParams đều tự là dynamic và gọi lại liên tục khi vào rồi.
Chú ý component Page có searchParams mà chưa await nó thì vẫn là phần static, khi truyền vào con và con gọi await searchParams; thì con mới là dynamic.
Chỉ các component dynamic mới cần dùng prr chứ static xây hết ở build time thì k cần, khi đó mọi dynamic part cần được wrap vào Suspense nha, phần static sẽ render ngay build time, phần dynamic sẽ render ở runtime.



# Template layout trong app router
template.js giống layout.js, layout wrap template, template wrap pages. Đb là template sẽ reset state bên trong khi navigate, còn layout sẽ preserve state. 
Tức layout thì state được giữ nguyên khi navigate sang page khác dùng cùng layout, nhưng template thì state reset khi navigate sang page khác dùng cùng template.
VD: layout chỉ hiện fallback của Suspense ở lần đầu vào, các lần sau quay lại k hiện vì nó preserve state rồi, template sẽ hiện Suspense mọi lúc navigate tới.

layout.tsx thay thế _app.tsx và _document.tsx của pages router
Thẻ để trong <head> trong layout sẽ tự chuyển xuống cuối của <head> trong html đích

-> default.js sẽ thay thế slots. Buộc phải có nếu route thiếu nested slots, k sẽ lỗi 404.



# Static file serving
Đặt file static trong thư mục public rồi truy xuất đến nó từ bất cứ file nào với /<đường dẫn kể từ thư mục public>
Chú ý truy xuất k được có relative ở đầu kiểu: ./abc.png vì như này nó k tìm trong thư mục public mà tính từ đường dẫn router hiện tại.
Static chỉ có tác dụng trong các TH link hay ref, còn import thì ta cứ import thoải mái theo relative thư mục.

-> import.meta.url trả về url tuyệt đối của file hiện tại
process.cwd() url relative đến dự án hiện tại. VD: /Users/mac/Desktop/MyLaptop/SetupProjectNextjs



# Thư viện đi kèm
URL: https://nextjs.org/examples chứa đủ loại example kết hợp redux với các thứ khác như threejs, redux toolkit, tailwindcss

-> chakra-ui, chakra-react-select
-> *tailwind

-> SWR (stale-while-revalidate) cung react hook cho data fetching, cache, lưu async state. Ít tính năng hơn react-query nhưng đơn giản hơn.
Redux toolkit cũng có tool query để thay thế react-query là rtk query

-> *Các tool formatter như reactjs: Chỉ cần eslint + prettier + eslint-config-prettier để tránh xung đột là đủ. 
K cần eslint-plugin-prettier, cái prettier/recommended thực chất là eslint-plugin-prettier k dùng

-> *autoprefixer tự thêm các tiền tố (vendor prefixes) vào CSS khi build để tăng khả năng tương thích trên các trình duyệt khác nhau. Nó dùng dữ liệu từ Can I Use để xđ các tiền tố nào là cần cho các quy tắc CSS đang dùng
*postcss là một công cụ xử lý CSS bằng code JS, nó là nơi các plugin css được cài vào để dùng.
*cssnano là 1 plugin của PostCSS. Nó giảm size của các tệp CSS bằng cách minify (loại bỏ các khoảng trắng, bình luận, viết gọn mã, và hợp nhất các quy tắc) giúp tăng tốc.

-> *react query dùng phía client có thể dùng trong nextjs app router.

-> *hero icons

-> *Payload: là 1 headless CMS chỉ cung cấp API k có FE. Điểm đb là có thể nhúng thẳng vào NextJS codebase mà k cần hosted. Cài 1 phát tự có sẵn hàng loạt tính năng phức tạp.
Self host CMS là loại tự cài vào dự án và tự host lên bth. SaaS CMS là loại có dịch vụ đám mây sẵn, k cần quản lý gì, chỉ cần gọi api của nó thôi. Payload là best self host CMS, Contentful là best SaaS CMS.
NextJS có cả BE và FE rồi nhưng vẫn nên dùng thêm CMS sẽ hỗ trợ thêm các tính năng của server mạnh mẽ hơn như authen, quản lý bài viết (kiểu blog web), draftmode, đa ngôn ngữ, tích hợp với các dịch vụ ngoài như google analytics, CRM, strapi api. Nó chỉ giúp làm dễ hơn thôi.

-> *react-next-parallax

-> Trending tạo website cực nhanh:
*shadcn: thư viện giúp xây component, nó có re-usable component và code sẵn dùng các lib khác để ta tự copy paste và custom chứ kp component sẵn. shadcn có components, blocks, charts, themes, colors sẵn tuỳ ý custom. Kết hợp với cursor và v0 nữa. Nó khiến bước tự code design trở nên nhanh và dễ dàng.
=> shadcn thay thế bằng https://originui.com/ tương tự nhưng lại có nhiều variants hơn
Kết hợp tailwinds và components của tailwind nữa là được => luôn phải có tailwinds, k cần tải thêm lib mà chỉ cần code thuần components dùng tailwind thôi.
Kết hợp shadcn template, tailwinds template để có website ui luôn.
Kết hợp *magic ui cho components độc lạ: https://magicui.design/
Kết hợp tailwindcss-motion tạo animation, có preset sẵn, có playground tùy ý custom, có chrome extension. Còn có tailwindcss-animate, animate.css.
***https://auto-animate.formkit.com/ => best lib auto-animate nhưng k customize được gì cả. Khi cần animate nhẹ thì thêm 1 dòng code và để nó tự động thôi.

Kết hợp https://enhanced-button.vercel.app/ mở rộng button cho shadcn
Mở rộng thêm components cho shadcn: https://shadcn-extension.vercel.app/
Mở rộng nữa nhưng khá xấu: https://shadcnui-expansions.typeart.cc/

-> next-video



# Environment variables
Định nghĩa trong .env.local chỉ dùng cho BE, nếu có tiền tố NEXT_PUBLIC_ thì FE mới có thể truy cập. Dùng @next/env để truy cập
Với env var ở BE có thể truy cập ở bất cứ chỗ nào server chạy qua như getServerSideProps hay chạy qua 1 lần trong FE components khi client request. Để giữ bí mật, nó chỉ được tính toán vào build time

-> Thứ tự ưu tiên load env: process.env > .env.$(NODE_ENV).local > .env.local (Not checked when NODE_ENV is test) > .env.$(NODE_ENV) > .env
Luôn để file .env*.local luôn để trong gitignore

-> Ta thường chỉ dùng 2 môi trường với .env.development.local và .env.production.local, còn .env.local dùng với mọi môi trường thường làm set default values.
VD truy xuất bằng .env.$(NODE_ENV).local với package cross-env (cross-env có thể chạy trực tiếp trên command nếu cài -g) => Khi dùng NODE_ENV, next tự động dùng đúng file .env developement hoặc production mà ta k cần set gì thêm 
VD có thể dùng file .env lưu giá trị mặc định cho biến môi trường, .env.development lưu giá trị mặc định cho biến môi trường development để k set gì vẫn chạy được, các giá trị này k cần bảo mật, còn .env.development.local lưu giá trị secret ta set cho biến môi trường development nhưng cần che giấu và k cho lên git
=> Hiện tại k cần dùng cross-env nữa. Ta có thể xác định NODE_ENV khi chạy để yêu cầu dùng file env nào luôn. Default NODE_ENV là development cho npm run dev, các lệnh còn lại tự là production.

-> loadEnvConfig trong next/env giúp load env file vào process.env. Dùng khi cần chạy script or command ngoài nextjs vì nextjs chỉ tự load env var khi chạy next dev/build/start thôi. VD chạy script viết bằng JS, dùng cho ORM, commandline cần dùng process.env

-> Cách tạo ứng dụng multi-env với docker: example with-docker-multi-env
Cơ ché là tạo mỗi môi trường 1 file .env rồi tạo Dockerfile cho từng môi trường, mỗi môi trường chỉ cần copy code và file .env tương ứng vào container r build và start.
Chú ý chạy bước copy trước rồi mới build vì bản chất khi buid sẽ nhét tất cả giá trị của biến môi trường có NEXT_PUBLIC_ fix cứng vào JS thì k đổi được nữa.

--> 1 cách khác hơi tù nhưng giải quyết được là để build trước ra code duy nhất rồi ốp môi trường vào sau là dùng await connection() trong server component. Hàm này sẽ chờ k chạy tiếp cho đến khi user request lấy component này thực tế, cản hết cả prerendering hay render at build time.
VD: export default async function Page() {
  await connection()
  const rand = Math.random()
  return <span>{rand}</span>
} => server component này k call api thì được render static vào build time nhưng như vậy giá trị random sẽ fix cứng, dùng await connection() sẽ ép nó dynamic render runtime mà k cần dùng dynamic api.
=> Tương tự dùng nó rồi lấy env var bên dưới đảm bảo build sẽ k lấy fix cứng nữa

--> Cũng có cách lấy runtime config nhưng k ai dùng nữa: https://nextjs.org/docs/pages/api-reference/config/next-config-js/runtime-configuration



# instrumentation.ts
Export ra 1 hàm register, hàm này sẽ tự động chạy 1 lần ngay khi 1 instance nextjs server được khởi tạo. Kiểu constructor của server.
VD tích hợp thêm các tool monitoring, logging vào server. Có thể dùng module nodejs.

-> after(callback) giúp thực hiện callback sau khi response hoàn thành, kiểu 1 side effect k muốn block rendering. VD log or analytics.
Có thể dùng trong Server Components (hàm generateMetadata), Server Actions, Route Handlers, and Middleware.
after tự hỗ trợ khi self host, nhưng nếu tắt app nên tắt chuẩn bằng cách gửi SIGINT or SIGTERM. Nó đảm bảo chờ promise trong after done mới tắt.
Vercel hỗ trợ hàm tương tự là waitUtil(), dùng nếu deploy vercel.

--> NextJS tự detect các page k dùng dynamic API thì là static page, khi có await connection() cũng thành dynamic page. 
Chú ý khi dùng after, nó không phải dynamic api và k khiến static page trở thành dynamic. Nếu dùng static build nó sẽ chạy 1 lần lúc build time, hoặc chạy lại nếu có revalidate



# draftMode
draftMode là 1 flag được set bởi 1 người dùng và chỉ có tác dụng trong 1 phiên hiện tại, flag lưu trong session-cookies, chỉ ảnh hưởng chính ngừoi dùng đó.
Thường dùng khi nextjs kết hợp CMS support draftmode, làm các tính năng như chuyển giữa draft preview và production. VD blog web.

Cơ chế: 
- Tạo 1 route handler /draft nhận 1 secret và url. Check secret hợp lệ và url route hợp lệ thì redirect đến url đó. 
- Tại url redirect đó, check nếu draft mode enable thì fetch API của draft mode, nếu k thì fetch như bth. 
API lấy bài viết dạng draft được cung bởi CMS luôn nếu nó support. Nếu k có CMS mà tự custom lưu vào db table draft thì lấy từ đó.
- Tắt preview thì xóa khỏi session cookie thôi.
Lưu ý draftMode lấy hay k chỉ được ở server, client muốn lấy phải gọi api đến server (với app router).

1 số CMS có UI, 1 số chỉ cung BE API. 1 số cho ta input redirect url khi ấn preview mode trên CMS thì ta nhập cái url draft của nextjs vào, kèm secret token.
User ấn nút preview 1 bài viết ở trên nextjs, hoặc trên CMS hay bất cứ đâu miễn là call vào route handler draft mà chuẩn secret token thì sẽ toggle draftmode trong session cookie và redirect đến bài viết ở dạng draft.
secret token chỉ được lưu trong .env của nextjs và preview url của CMS. 
Page router dùng context.draftMode, app router dùng (await draftMode()).enable();



# Dùng next/head 
Có thể chỉnh sửa <head> của web. 

VD muốn thay đổi thẻ title mà dựa vào 1 biến, ta phải tạo 1 biến string title và truyền cả vào chứ k nên dùng {<biến>} vì ta muốn truyền vào 1 node nhưng nếu dùng {} nó sẽ tách ra thành nhiều node. VD: Hello {"World"} nó sẽ sinh ra Hello <!----!> World tức <text><comment><text> là 3 node k nên => cứ view source page xem có đúng tên title k là được

VD có thể thêm file css tĩnh cho web qua thẻ link cho vào head, thì thêm ở component nào sẽ chỉ có tác dụng khi component đó được render. Vì mỗi khi 1 page được render, mọi phần head và body sẽ được thay mới theo các component bên trong nên đống thẻ link đó sẽ k có tác dụng với các page ở component khác.

-> Để hiện thumbnail bth trên MXH nên có tối thiểu 2 thuộc tính og:image và og:title trong thẻ head

-> Dùng robots.txt: Crawler đi qua file này trong public đầu tiên trước khi crawl bất cứ thứ gì trong domain.
Có thể dùng để bảo vệ 1 vài phần trong website tránh bị crawl như admin or user account or CMS, API route
VD: truy cập vào http://localhost:3000/robots.txt được sau khi tạo xong

-> Còn có import { cookies, headers } from 'next/headers' lấy cookies từ header
NextJS v15 luôn dùng await khi dùng async: const cookieStore = await cookies(); const headersList = await headers()
Phía server như middleware, server component, route handler, server actions luôn có thể read/write cookies. 
Phía client thường k cần truy cập, dùng document.cookies để acccess httpOnly false nếu cần, nếu muốn đổi, nên gọi tới server để đổi, hoặc gọi tới server để get cũng được. Có thể truyền data từ server tới client props hoặc nhét vào params để dùng useParams. 



# Metadata => bỏ next-seo
export metadata => fix metadata
export generateMetadata({params}) => dynamic metadata

-> NextJS có ImageResponse giúp tạo component hiển thị Image động là code html css. Ta tạo 1 api route trả về ImageResponse và dùng nó trong src của <Image>, nhận tham số và trả ra data tương ứng với tham số (tức là data động theo url đó). Hoặc tạo icon.tsx export default hàm trả ra ImageResponse tương tự.
export generateImageMetadata k có tác dụng gì cho SEO, chỉ cung thêm thông tin cho image động.
generateImageMetadata trả ra 1 mảng là nhiều version khác nhau của image mà người dùng nhận về khi nhét url vào src. Các phần tử trong mảng có trường id và params của component image cũng nhận object có trường id để lấy đúng metadata tương ứng, metadata quyết định kích thước hay extension các thứ, từ đó nextjs sinh ra các ảnh khác nhau để dùng.

-> Set opengraph-image tự có twitter tag. Set twitter tag sẽ ghi đè phần twitter. File route con đè route cha 
opengraph-image.tsx thì font lấy từ chuẩn gg, lấy font trang khác bị lỗi khi build

-> Nếu cấp ngoài cùng có metadata, thì it nhất cũng phải có export metadataBase ở cấp ngoài cùng để tránh warning k có canonical url. Rồi metadata ở con sẽ đè hoặc thêm vào cha dần khi set.



# Dùng next/image
Cung <Image> giúp tối ưu hóa hình ảnh. VD ảnh 2000x2000 nhưng trên màn hình mobile, ta chỉ cần tải kích thước 100x100 pixel là đủ rồi thì sẽ giảm tải vc load ảnh, giúp tăng performace. Nó cũng tự động lazy loading, preloading xác định kích thước ảnh tương ứng với thiết bị mà k cần code gì thêm.
Khi dùng như v mà resize màn hình thì nó sẽ liên tục query image tối ưu hóa cho màn hình hiện tại, mở tab network sẽ thấy query lại liên tục. Server next cũng tự tối ưu ảnh input sang webp.

-> Dùng <Image> của next/Image tuy ép có width và height nhưng có sẵn các tính năng placeholder, blurDataURL, onError xử lý lỗi và hiển thị placeholder. Có thể dùng kèm thư viện plaiceholder giúp tạo ảnh placeholder mờ cho nextjs
URL ảnh có thể từ bên ngoài nhưng tối ưu nhất là dùng ảnh static trong thư mục public
Ưu tiên load image với nextjs dùng thuộc tính priority, tương tự thuộc tính preload của <img/> trong html => dùng ít vì càng nhiều ảnh sẽ càng giảm tốc độ tải trang.
Còn có: onLoadingComplete, quality, onLoad, sizes. URL: https://nextjs.org/docs/pages/api-reference/components/image
=> Chú ý dùng các event với on sẽ biến nó thành client side component, nhưng k thể viết hàm xử lý sự kiện client trong server component được nên phải tách ra client file.

-> Setting next.config.js
VD bỏ optimize: "images: { unoptimized: true }"
Xđ URL của ảnh trong next.config vì server phải vào url đó để lấy ảnh về xử lý. Nếu gặp TH kẻ xấu có thể khiến server vào website do hắn yêu cầu để lấy ảnh thì hắn có thể để thật nhiều những tấm ảnh vô cùng lớn khiến cho server xử lý quá tải bị DDoS.
Ảnh từ local nextjs tự tối ưu mà k cần specific width height thì k nói. Ảnh từ remote thì server cũng tối ưu nhưng phải rõ width height hoặc dùng layout="fill"

--> Nextjs có thể custom loader or dùng built-in loader hỗ trợ cloudinary, cloudflare, aws,.... là 1 thuộc tính của <Image> hoặc specify trong next.config.js
NextJS có sẵn image optimization api, có thể chuyển sang dùng cloud provider khác. VD: images: { loader: 'custom', loaderFile: './my/image/loader.js' }
Loader là 1 hàm or tách ra file riêng giúp xây url để lấy image từ src, width, quality attributes. Nếu deploy trên vercel, k cần config gì thêm.

-> Nếu k dùng được width height cụ thể thì phải dùng thuộc tính layout="fill". Thuộc tính này sẽ tự hiểu là ảnh sẽ chiếm theo không gian của thẻ cha nên chỉ cần specific width height cho thẻ cha có position relative (buộc có) bao nó là được. Dùng kèm objectFit, objectPosition, aspectRatio.
Hoặc ảnh k rõ kích thước và ta k muốn dùng optimizer thì dùng tag img bth hoặc dùng next/image nhưng thêm width và height = 0 (search có) rồi kèm style chỉnh lại width và height css, làm v thì optimizer k hoạt động thôi.

-> Khi nào k dùng <Image>? Khi k trust domain mà web ta load ảnh.

-> Có thể quản lý cache của optimized image nhưng chắc chẳng bh dùng: https://nextjs.org/docs/app/api-reference/components/image#caching-behavior\
Mặc định image được cache trong memory của server sau khi optimize bất kể image từ ngoài hay local, đến khi expires mới xoá.



# Routing
Routing chia theo cấu trúc file thư mục, cả be và fe. 

-> Dynamic route
Page router dùng getServerSideProps, getStaticProps như bth. App router dùng fetch và các options đi kèm.
getStaticPaths thay thế bằng generateStaticParams giúp xđ tham số cho dynamic routes ở server side mà async, VD fetch API ra list params rồi cho vào page.tsx hoặc layout.tsx lấy Page({params}). Sau đó sẽ dùng để generate ra STATIC SITE. VD hàm sinh ra 10 tham số để build ra 10 pages.

NextJS v15 dùng await khi gọi trong hàm async. VD page.ts:
export async function generateMetadata(
  { params, searchParams }: { params: Promise<{ slug: string }, searchParams: Promise<{ [key: string]: string | string[] | undefined }> }
) {
  const { slug } = await params
  const searchParams = await searchParams
}
Nếu sync usage: 
const params = use(params)
const searchParams = use(searchParams)

=>*** Điều đặc biệt là params truy cập ở server phải dùng await và khi await thì kể cả page là static dùng static build cũng thành dynamic build. Còn client truy cập lại éo cần await gì cả, useParams luôn.

-> Page Routes: thư mục pages chứa file chia routing. 
Fetch data qua getServerSideProps, getStaticProps, revalidate, getStaticPaths.

-> App Routes: thư mục app chia tương tự nhưng khác ở chỗ fetch data => Đầy đủ: https://www.youtube.com/watch?v=gSSsZReIFRk
Full example master routing: https://github.com/vercel/next-app-router-playground
K cần dùng folder src nữa vì sẽ thành src/apps thôi, trừ khi muốn dùng cả src/apps và src/pages 1 lúc.

Mặc định mọi component là server side, chỉ khi có "use client" mới là client side. Khác với page routes có thể viết client side fetching và server side fetching chung 1 file component thì ở app router, mỗi loại phải chia file riêng. Bắt đầu từ 1 server side component ở node gốc của cây, có thể import client side comp vào server comp nhưng k thể ngược lại.
VD khi để export static trong file config, mọi hàm fetch server side sẽ thành tĩnh cho kết quả cố định, hàm fetch client vẫn ok. 
VD dùng react-query ở client side thì vẫn share state cho nhau bth thôi. 
VD server muốn truyền state cho client component, phải truyền vào props. VD 1 file vừa có getStaticParams, vừa có "use client" là sai ngay với app router vì k thể mix trong 1 file.

Để fetch data server side, dùng async function component với await fetch() bên trong, default là static web tức gọi lúc build và fix cứng. Dùng thêm options như cache:"no-store" để fetch lại liên tục như SSR hay next:{revalidate:5} để làm mới sau mỗi mỗi 5s => tức thay thế getServerSideProps và revalidate của pages router
Để thêm loading cho server side fetching, wrap lại với Suspense fallback là được.
URL khi nào dùng client comp hay server comp: https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns
Có thể viết common component ở các vị trí mà next ignore for routing: apps/components; bất cứ thư mục nào có _ prefix; file ở cấp ngoài cùng của apps mà khác các tên đặc biệt như layouts, pages; dùng src/components cùng cấp src/apps. VD để components trong app k tính routing nếu folder k có page.js
Dù nói là App Router dùng Server Component nhưng k có việc đổi props mà phải chạy fetch lại, nó chỉ là kiểu thay thế các hàm fetch phía server của Page Router thôi.

-> Chuyển trang đâu cần chia CSR hay SSR: Dùng thẻ <a> ref ra link ngoài; Dùng useRouter và Router chuyển trang CSR; Dùng next/link cho <Link/> chuyển trang CSR
next/navigation cung redirect dùng ở server component, cũng cung hàng loạt hook như useRouter, usePathname, useSelectedLayoutSegment cho CSR.
useSelectedLayoutSegment thì client component phải nhét vào layout.js mới hoạt động, nó trả ra các path kể từ cái layout đó đến path mới nhất => ít dùng
useSearchParams trả ra readonly version thôi

-> Prefetch: - Dùng <Link> từ next/link tự động prefetch pages trong href nếu rảnh giúp tăng tốc nextJS => Luôn dùng <Link> trong mọi TH có thể. Có thể chặn khi dùng <Link/> với prefetch={false} để cản với các trang ít khi người dùng vào => prefetch chỉ có tác dụng trên production (build r start), k test được ở dev.
- Dùng useRouter có router.prefetch(url, as, options) để tùy biến prefetch với mọi trang. URL là trang muốn prefetch chơi cả router fix or dynamic routes như /product/[id]
Với page router: Chỉ prefetch static pages chứ SSR pages vẫn fetch lại delay như thường.
Với app router: true false sẽ prefetch or not cả dynamic và static. Để default null là hay nhất vì static route sẽ prefetch hết bao gồm cả data bên trong. Còn dynamic route thì 1 phần route từ gốc cho tới phần segment gần nhất dùng loading.js sẽ được prefetch (phần segment là các cục /segment1/segment2/...) tức nó prefetch phần tĩnh nh nhất có thể.
Thời gian nó cache prefetch là 30s, hết hạn sẽ tự prefetch tiếp luôn
=> prefetch phải dùng cẩn thận vì nó gây ra nhiều behavior k tốt. Vd nó prefetch 1 route từ server, nhưng ta lại đổi data lúc vào pages thì server k fetch lại nữa là sai, phải đảm bảo page hiện tại k thay đổi data của page đang prefetch và set stale time cho đúng.

--> useLinkStatus giúp lấy status khi chuyển trang. Nó chỉ dùng khi page dynamic k cần prefetch và k có loading.js tức là k có instant navigation, chỉ có từ v15.3
Chỉ dùng trong component là con nằm trong <Link/>

-> Custom 404: app router dùng notfound.js, page router dùng 404.js
Tạo layout: cả app và page router đều có thể dùng layout.js. Nhưng cũng có thể dùng _document tạo layout thay vì dùng component layout riêng. 
K dùng stylesheet trong <Head/> kiểu <link rel="stylesheet" .../> vì có thể bị break khi dùng các tính năng Suspense or streaming. Nếu muốn thì ta chỉ được dùng trong file _document.tsx thì để kiểu gì cũng được

-> PopState Event là event của window được kích hoạt khi user navigate qua lại giữa các page và history entry được push vào history stack.
Dùng router.beforePopState có thể thao tác với 2 button navigate của browser

Dùng router group: đặt tên folder trong () sẽ k ảnh hưởng đến routing, nó coi như k mất phần url folder đó trong path.
URL: https://nextjs.org/docs/app/getting-started/project-structure#route-groups

-> Nó chia route theo phạm vi từng component là từng thư mục riêng sẽ hiển thị khác nhau theo các route khác nhau.
Nếu wrap bằng Suspense trong layout thì sẽ hiện component loading trong fallback. Nếu k thì phải tạo loading.js sẽ tự hiện loading component khi server fetch api.
Đầu tiên nó luôn hiện layout.js với children hoặc là page.js hoặc là nested route folder bên trong. 
Nếu tìm 1 route k có, sẽ tìm default.tsx để thay thế, k có nữa sẽ tìm dần tới cha đến khi gặp not-found.tsx 
Lỗi thì error.tsx
=> Ref tới "Projects / Portfolio"

-> intercept route: ghi đè hiển thị khi navigate từ 1 route sang 1 route khác, nó sẽ hiển thị khác đi trong case đó, VD hiển thị dạng modal preview, khi close sẽ vẫn ở trang gốc.
Chú ý phải xoá .next folder và chạy lại mới ăn.



# Pages router và hiểu SSR trong nextjs
-> Dùng getInitialProps: K dùng mà thay thế bằng getStaticProps và getServerSideProps. Chỉ dùng được trong /pages ở từng file component, k được dùng ở các thư mục ngoài pages như components bth cũng k được
Hàm này chỉ thực hiện ở server để fetch data nhét vào DOM r gửi lại cho client html đã hoàn chỉnh. Mỗi khi có request, server sẽ lại chạy nó và lại cho vào DOM.

--> Thử tùy biến: Nếu ta host cả server này lên thì nó mới là Universal SSR.
Nếu ta build và export thành html tĩnh và host lên firebase thì chuyện gì xảy ra? Hàm này chỉ chạy phía server mà export static ra thì k còn server nữa mà thành html fix. Nên next build thì server sẽ thực hiện 1 lần duy nhất chạy qua tất cả, đến khi export sẽ chạy qua getInitialProps sinh ra data luôn. Export ra tĩnh chỉ được chạy 1 lần lúc build time rồi k cần server nên nó chạy qua và cứ chơi các giá trị mặc định nên data sau khi host lên sẽ kbh đổi và hàm này trở nên vô dụng vì k có server.

-> Dùng getStaticProps:
Hàm chuyên dùng cho SSG, dùng để fetch data lúc đầu tiên vào web. Khi ta build web, nó sẽ fetch data 1 lần duy nhất và thành file html cứng luôn cho ta, khác với getInitialProps thì mỗi lần có request nó sẽ chạy lại thì cái này chỉ chạy 1 lần.
Thế tại nếu chỉ chạy 1 lần tức là data fix cứng, tại sao ta k viết cứng cho nó luôn? => Vì nếu có 1 triệu data thì ta đâu thể gõ cứng vào mà phải fetch r in ra chứ. Nó sẽ fetch trước mọi trang ta xác định, kể cả dynamic params page.

Hàm này chỉ được thực hiện ở phía server vào lúc build time, nếu muốn update data đương nhiên phải build lại r export lại và host lên. Sau khi build, tốc độ dùng web sẽ cực kỳ nhanh, cộng với bộ cache lớn thì tốc độ sẽ cực kỳ nhanh.
Chỉ được dùng 1 loại, k được dùng kèm getInitialProps

--> Dùng với dynamic params: 
Cần tạo nhiều trang static với đường dẫn động từ dữ liệu tại thời điểm build. Ta dùng getStaticPaths định nghĩa các url muốn pre-render ngay từ lúc build. Vì dynamic thì built time nó k rõ url có giá trị gì để prefetch nên hàm này chỉ giúp điều đó thôi. Lúc build sẽ fetch tất cả và cho ra hàng loạt file html là trang tĩnh.

---> Hàm getStaticPaths trả ra object có:
Trường paths: là list các dynamic params.
VD: pages/posts/[postId]/[commentId] thì trả về kiểu {params:{postId:1,commentId:2}} 
VD: pages/[...slug] thì trả kiểu {params:{slug:["hello","world"]}} và sinh ra page /hello/world
Mọi route kiểu null, [], undefined, false, VD slug:false thì Next tự cho ra "/"

Trường fallback:
- false thì mọi path k trả ra bởi getStaticPaths sẽ ra 404 page (next build chỉ build các path xđ trong getStaticPaths) => thg dùng kiểu có ít page ban đầu, dùng như v thì sau này thêm page vào thì next build phát là xong
- true thì page k có trong getStaticPaths sẽ được fetch và trong lúc chờ loading sẽ hiển thị ra fallback page, fetch xong mới hiển thị ra page bth => thg dùng khi có rất nhiều page. VD có 1 triệu page nếu ta fetch hết sẽ có 1 triệu file html mà đâu cần mức đấy. Ta có thể fetch 3 item page đầu, các page sau ta để loading or skeleton ok.

Quy trình: dùng getStaticProps và getStaticPaths cho 1 vài pages thôi, trong component check nếu router.isFallback==true là đang loading 1 page chưa từng fetch, nếu !router.isFallback&&!data thì là vào trang k tồn tại. Còn lại là vào đúng.
fallback page ta nói ở đây chính là cái page gốc nhưng data truyền vào k có gì cả và router.isFallback là true
=> 1 tính chất quan trọng của cái này là ta thấy ở thư mục build ra (.next) thì nó build ra từng page của trang web, nhưng khi 1 request tới 1 page k có trong getStaticPaths và nó bắt đầu fetch lần đầu tiên thì server sẽ fetch và tự rendered trong server, sau đó gửi lại cho client file html đó. File html đó được lưu lại trong server nên vào thư mục .next sẽ thấy có file mới, và kể từ lần sau trở đi tốc độ sẽ cực kỳ nhanh vì nó coi đã fetch rồi. Điều này chỉ xảy ra khi host lên có server chứ kp host tĩnh. HTML gửi từ server sẽ thay thế trang fallback.

'blocking': Y hệt fallback true nhưng page k có trong getStaticPaths thì server sẽ tự fetch ngầm và nhảy lag đến chứ k có loading gì cả, router.isFallback cũng k có gì
=> getStaticProps vốn dùng cho static build, nhưng khi có getStaticPaths với options kiểu này thì phải hosting server SSG mới được vì cần fetch lại
=> Có thể kiểm chứng bằng tab network, khi query 1 page mới lần đầu mà server chưa có thấy tốc độ hơn 100ms, lúc đó nó được lưu lại tại server file html đó r nên khi query lần 2 page sẽ thấy tốc độ còn vài chục ms thôi.

=> SSG là giải pháp load page cực nặng với tốc độ nhanh. Nếu có 1000 page thì nó cũng prefetch 1000 page lúc build time rất lâu nhưng trải nghiệm người dùng lại nhanh

--> Incremental Static Regeneration
SSG thì cơ chế cũng chỉ là html được sinh ra ngay từ build time và nó fix cứng mãi, từ đó có thể bắn lên CDN k cần tới server. Trong next ta dùng server chạy nó bằng npm run start cũng chỉ để cung website static ra thôi. Nhưng nhược điểm lớn là thời gian build tỉ lệ thuận với số page của ứng dụng; 1 page có thể bị stale trước khi ta rebuild. V nên static generation chỉ dùng làm mấy cái trang docs thôi, nhưng trong thực tế, ta vẫn cần dữ liệu real time hơn 1 chút, nên có Incremental Static Regeneration
PP này giúp tạo được web tĩnh tốc độ cực kỳ nhanh và khá real time, phù hợp các app bth, giúp update data của page cần thiết mà k cần rebuild lại toàn bộ ứng dụng.

=> Trường revalidate của getStaticProps VD set là 10 tức là: cứ mỗi 10s trôi qua, request đầu tiên tới tiếp theo sẽ trigger regenerate page đó đồng thời gửi lại page cũ cho request đó. Sau khi regenerate xong, thì các request đằng sau sẽ được serve page mới và cứ thế chu kỳ lặp lại. Phải hosting server SSG chứ k được static build.
Đó là lý do vì sao data được update -> sau 10s request page -> vẫn nhận về page cũ -> request lại phát nữa -> nhận về page mới. Vì lần gọi vào đầu để trigger cái regenerate chứ chưa có data nên vẫn nhận stale. Có page set 1s, có pages set 60s tùy web. Nếu regeneration bị lỗi, sẽ serve page cũ ok. Thường dùng nếu data k thực sự quan trọng.

=> Nhanh:
getStaticProps fetch data lúc build time
getStaticPaths fetch data ở mỗi initial request rồi cached vĩnh viễn
ISR fetch data khi có request sau mỗi 1 ktg revalidate cố định nhưng chưa thực sự real time. Kể cả ta có để 1s thì nó vẫn stale-while-revalidate 
Có thể fetch data tại client thành CSR có thể đảm bảo fetch data ở mỗi request và trả về data mới luôn nhưng SEO kém
SSR fetch data r rerender page ở mỗi request mới và trả ra data mới luôn và đảm bảo SEO: getInitialProps, getServerSideProps
=> Tức là ta tạo CSR, SSG, SSR hay ISR tùy ý code, nhưng khi export và deploy thì phải tùy loại mới chạy được kiểu nào cụ thể.

-> Dùng getServerSideProps: Chỉ được gọi ở server, phần code viết trong getServerSideProps k được included trong JS bundle gửi tới browser. Có thể viết cả API key thoải mái. Ta có thể code như hàm xử lý middleware trong server nodejs như đọc file hay truy xuất database
Do SSR chậm hơn SSG nên chỉ dùng khi cần thiết về độ realtime. SSR k build trước html ở build time như SSG và luôn regenerate lại ở mọi request, k lưu lại html ở server
Cái getStaticProps k truy cập được vào biến request và response ở trong hàm nhưng getServerSideProps thì ok

--> Giải quyết vđ nếu 1 page fetch lần đầu data lớn gây loading lâu. Mà để chuẩn SEO thì phải dùng SSR. Mà như thế thì mỗi lần vào page, server đều fetch chạy lại getServerSideProps rất tốn. Có nhiều cách fix tùy TH:
- Có thể dùng CSR thuần riêng cho nó vì giả sử có 1000 items thì việc SEO cho cả 1000 items rất hiếm khi xảy ra, nếu các item giống nhau thì k cần thiết, nếu các items khác nhau thì SEO rất tạp nham chả vào chủ đề gì. Do đó có thể fix thẻ meta cho page đó or SSR fetch vài data đầu thôi, còn lại list data fetch dùng CSR. Append data từ CSR vào SSR render ra.
- getStaticProps + ISR revalidate tầm 60s cho pages đó vì sẽ k có nh sự thay đổi. Do nếu data thay đổi nhiều mà SEO tất cả thì rất khó xảy ra vì SEO k có ý nghĩa.
- Chia page, 1 cách để SEO tất cả là phân trang, mỗi trang là 1 router khác nhau thì SEO cho cả trang được, lượng data giảm nên fetch nhanh
=> Cách 1 thật ra k tệ vì ta k fetch detail mà chỉ fetch qua tên và type thôi nên tốc độ nhanh vì số lượng collection cũng k có nhiều 

-> 1 app có thể kết hợp nhiều kiểu: VD 1 pages dùng SSG (static HTML + JSON dùng getStaticProps vì phần data lấy từ getStaticProps được lưu vào file json), 1 page dùng ISR, 1 page dùng SSR, 1 page Static(chỉ có static HTML, k dùng getStateProps), 1 page dùng CSR (client fetching) => khi build hiện ra ký hiệu rõ route dùng kiểu nào
=> 1 dự án thông thường cứ chơi SSR hay CSR tùy hứng thôi, page lớn có thể CSR hết. Nếu SSR mà thấy fetch lớn quá thì dùng revalidate với ISR cũng được.

-> Dùng next/router (page router chứ app router khác hoàn toàn)
VD replace url mà k chuyển trang:
router.replace(
  {
    pathname: "/explore/[creator]/[collectionid]",
    query: { creator: item.creator, collectionid: item.collectionid },
  },
  undefined,
  { shallow: true }, // Do not refresh the page when the query params are removed
);
Trong _app.tsx dùng router.on để bắt sự kiện khi router đổi, thì router có option shallow true giúp đổi url vẫn trigger sự kiện nhưng k chạy lại getServerSideProps nữa => thích hợp cho url chứa filter



# Style 
-> Style css thuần: K nên dùng file css static trong link stylesheets của thẻ <Head> như css thuần vì rối. Ta nên dùng import relative, đặt tên file cùng cấp với quy tắc khi import <Component>.module.css và phải import dạng biến và dùng cho từng className

-> Dùng "npm install --save-dev sass". import relative như css, tuân thủ quy tắc đặt tên bth

-> Style inline chỉ ảnh hưởng 1 component với <style jsx>{``}</style>
<style jsx> sẽ inject style class css lúc runtime vì nó hiện ra như 1 tag rồi browser mới dùng để style, điều này làm client side bị lag, button hiện ra rồi mới styles nhảy. Dùng file index.module.css tốt hơn vì nextjs bundle nó ở build time và lúc server render sẽ dùng luôn là chuẩn
Dùng <style jsx> phải để ở cuối component để tránh lỗi hydration. Dùng có thể cản các lỗi css unsupported.

-> Next cũng hỗ trợ sẵn styled-components xem trong docs => Có thể dùng nó để tạo component custom như 1 bộ thư viện riêng cho mình

-> Style global: - Dùng thư viện UI riêng
- Tự setup 1 file static global css rồi link hoặc relative import nó vào pages/_app.js chung là được => Cơ chế khác nhau: dùng <link> nó sẽ link file như 1 static file, còn dùng import relative nó sẽ tự động biến thành thẻ <style> đặt trong <head> cho ta

-> Dùng :export trong scss file khai báo biến lấy dùng trực tiếp trong JS, cần scss loader module nextjs có sẵn r



# Dynamic import
Thường dùng dynamic import cho các hàm từ thư viện lớn mà code k dùng nhiều, VD phải ấn nút mới gọi.

Khi compile, mỗi page của app được NextJS compile thành từng file riêng gọi là chunk, khác với ReactJS khi chỉ sinh ra 1 file html và js duy nhất
Khi browser request 1 pages, lần lượt: 
Nó nhận về file html
Nó request tải tất cả các file js còn lại của page hiện tại
Nó đồng thời đọc file html hiển thị ra và request tiếp các data cần cho file html hiện tại thôi. 
=> Dùng lazy load của React hay dynamic import của next sẽ cản việc request tải các file js chưa cần dùng ngay. Khi rảnh cũng chạy prefetch nếu set.

-> Trong next có cả server và client:
Khi client request vào 1 url, server sẽ chạy trước quét qua tất cả 1 lần, bao gồm cả import hay các thứ sẽ làm hết r gửi lại file js mà client yêu cầu. 
Khi dùng dynamic import cho 1 component, server vẫn làm như v và chạy qua cả file dynamic import, nhưng gửi về client sẽ k load các file dynamic import ngay nếu comp đó chưa cần hiển thị cho dynamic import component.
VD: ta dùng dynamic import cho component Hello mà file chứa nó chưa được load, khi ta ấn nút nó mới hiển thị, để ý tab Network sẽ thấy nó tải file thêm JS lúc đó. Còn nếu component Hello mà import bth thì vào phát client tải luôn, ấn nút hiện ra sẽ k thấy tải thêm file js nx vì nó đã tải trước r.

option ssr: false khiến dynamic client component cũng k bị pre-render và k có trong SEO luôn. Trước đó thì server vẫn chạy qua nên nó vẫn có ích cho SEO.
Không liên quan tới prefetch, khi có thì server sẽ prefetch data như bth thôi. dynamic import chỉ delay client side và chỉ dùng với client component

-> Có thể xử lý thêm loading cho dynamic import được với next/dynamic
Dùng next/dynamic và React.lazy + Suspense cho kết quả như nhau
=> Chốt: dynamic import từ next/dynamic, ssr false => chỉ dùng next/dynamic mà k dùng react lazy



# Build và hosting app nextjs
URL hỗ trợ 2 kiểu build: https://nextjs.org/docs/app/building-your-application/deploying
Nếu chỉ cần static site hoặc CSR thì dùng static export. Còn dùng bất cứ TH nào cần server thì phải dùng nodejs server.

-> Static export: NextJS hỗ trợ build static site ra html cứng để chạy k cần server. Rồi có thể host lên các trang hỗ trợ static site như Firebase, AWS, Vercel.
Tùy biến việc tạo app phải tương thích với kiểu build
VD: ta dùng getServerSideProps xong build static chắc chắn sẽ lỗi.
VD: ta dùng server side comp fetch data r build static sẽ tự fetch 1 lần duy nhất lúc build time. 
VD: ta dùng client side component fetch data thì static build vẫn fetch được vì k cần server để fetch ở client. Vd Ta build ra output:"export" rồi chạy live server trong phạm vi thư mục out là thấy fetch CSR.

-> NodeJS server: Khi chạy next build rồi next start tự tạo 1 node server chạy app mặc định. Nếu cần hosting cũng chỉ cần chạy như v.
Có thể phải cấu hình thêm next.config cho các kiểu build ISR các thứ.

-> Hosting: Vercel giúp hosting app react đủ kiểu, có thể connect với github tạo CI/CD. Chú ý phải đúng phiên bản React và Node khi deploy vercel.
Còn có DigitalOcean, Netlify, Railway, AWS với EC2, Netcup, Hostinger VPS



# Server Actions trong app router
Tương đương với việc gọi API route từ client component của page router. Pb:
- Page Router client trigger event -> API Route server xử lý -> Server update redis and return back JSON -> Client update UI
- App Router client submit form -> trigger server action run on server -> server update redis, revalidate cache, update UI and return back RSC Payload -> Client got new UI
=> App router tốt hợn có thể hoạt động tốt dù trình duyệt disable JS, check tab network sẽ thấy API trả về RSC payload. RSC payload chỉ là những phẩn cần render lại chứ kp cả pages nên tối ưu hơn, có thể revalidate khi xong để update cả pages.
=> Route handlers của app router tương đương với API Routes của Page Router. Còn Server Action chỉ có ở App Router

URL: https://nextjs.org/docs/app/api-reference/functions/server-actions => Setup trong next.config.js -> viết server actions -> dùng server actions trong component

Server action chỉ là 1 hàm, có thể dùng 'use server' trong hàm or trong 1 file để bảo cả file export ra hàm là server actions.
Server Actions chỉ được call trong actions của <form> hoặc formAction của các loại thẻ khác lồng trong thẻ <form> như <button>, <input>, useEffect, thirdparty
VD ấn button gọi tới 1 server action sẽ tạo request tới server chạy 1 hàm với params cụ thể và server thực thi trả về cho client.
Mỗi khi gọi server actions từ frontend, nó sẽ đưa lệnh vào queue và tự động lấy ra gọi lần lượt có delay chứ kp click nhiều lần là gọi chồng lên nhau luôn.

Vd pass thêm params vào server actions: 'use server'
export async function updateUser(userId, formData) { }
Trong component: const updateUserWithId = updateUser.bind(null, userId); 
<form action={updateUserWithId}></form>

=> Khi nào dùng? - Nếu gọi 1 hàm kp fetch API, nó vẫn gửi request tới server, server xử lý và update html trước khi gửi lại người dùng giúp SEO cho data đó
- Kể cả không cần fetch API nhưng cần xử lý tác vụ nặng, dùng server actions sẽ khiến chúng được thao tác ở server đỡ cho người dùng. 
- Nếu cần process thông tin nhạy cảm, để vào server actions là người dùng k thấy. Vd ta query API moralis cần API key mà frontend k được lộ cho người dùng thì có thể dùng nextjs lưu key đó là biến môi trường phía server và gọi an toàn với server actions thay vì mất thêm 1 server api trung gian.
- Server actions call được từ client nên cho vào react query call thoải mái
- So với route handler, server action gọn hơn và k cần xử lý cors, nên ưu tiên dùng.
=> API route cho kết quả tương tự, server actions hơn ở chỗ nó trả về html đã được xử lý luôn và k cần phải viết 1 api route mới nên tối ưu hơn thôi.

-> Update db trong server actions: VD update thông tin của dogs/[id] trong db
Trước kia ta viết 1 api "api/dogs/[id].ts rồi phía "use client" fetch tới nó. Rồi call router.refresh() cả page hoặc nhận về data r update
Nếu dùng server actions: server component fetch default value là giá trị trong db -> ấn nút thì chạy server actions update db -> revalidatePath để load lại data của server component nào 

-> NextJS v15 dùng await trong hàm async. Nó lấy được segment params:
export async function GET(request: Request, segmentData: { params: Promise<{ slug: string }> }) {
  const params = await segmentData.params
  const slug = params.slug
}

-> URL đầy đủ: https://www.youtube.com/watch?v=BWJJwk2j-7A
Để revalidate 1 api thì gắn tag cho nó + revalidateTag, để revalidate mọi api trong 1 route url thì dùng revalidatePath
@vercel/postgres có sql query trực tiếp vào db có thể chống sql injection khi dùng template string tự lấy giá trị nội suy sql`lệnh{<variables}`
Điều đặc biệt là "use server" dùng trong 1 function sẽ giới hạn function đó được thực hiện ở server chứ kp nó là 1 server components. Họ vẫn muốn dùng file như 1 client component nên tách phần code server đó ra file riêng.

-> import { cache } from "react"; kết hợp cache của react chỉ dùng ở server side giúp các request api được memoized chỉ call 1 lần khi gọi nhiều lần đồng thời. Lưu ý nó cache trong 1 session nên phải tự refresh cached. 
VD: let fetchData = cache(async (id) => {
});
function refreshCache() {
  fetchData = cache(async (id) => {
  });
}
await fetchData(1); // Fetch lần đầu, lưu vào cache
refreshCache(); // Reset cache
await fetchData(1); // Fetch lại từ API

-> Khai báo server actions ở file bất kỳ trong app/api hoặc trong bất cứ folder component nào miễn là có "use server" ở đầu
import "server-only" và còn có "client-only" bảo rằng mọi thứ export ở file hiện tại chỉ có thể được import ở server component hoặc client component. 
Thường dùng cho server fetching actions khi tách ra 1 file riêng giúp việc call data đó được tái sử dụng ở nhiều nơi ok.
import server-only đảm bảo hàm chỉ được import ở server side, use server đảm bảo hàm được import ở bất cứ đâu nhưng chỉ thực thi trên server
default là "use client"

-> revalidatePath và revalidateTag không giúp refresh lại khi 1 route có nhiều server component nhưng chỉ muốn refresh 1 component trong đó và k dùng fetch. 
Giải pháp là dùng dùng refreshKey truyền vào server component, muốn refresh cho component nào thì tăng key +1 lên để nó render lại sẽ call lại api => pp này chỉ dùng khi render ít component thôi. Còn client side thì render lại ta dùng useEffect hoặc react-query có refetch lại thì render lại mà



# Dùng API Route
URL endpoint API chia theo cấu trúc thư mục. VD pages/api sẽ tạo đường link tương ứng là /api/<tên file>
Usecase: dùng làm BFF server; dùng để masking URL tới external service để bảo mật. VD: thay vì gọi https://company.com/secret-url thì gọi vào /api/secret r chuyển hướng url.
Có thể gọi revalidate path để server load lại data của server component nào. Có thể tạo middleware xử lý cookies như 1 nodejs server bth => next-example có đủ VD dùng cors, cookies.

-> Dùng Edge API Route: Có 2 loại là NodeJS based API Routes và Edge API Routes. Edge API Routes sử dụng Edge Runtime nhanh hơn NodeJS based API Routes (dùng NodeJS runtime) vì nó sẽ deploy lên máy chủ biên gần với ngừoi dùng cuối hơn máy chủ trung tâm.
Dùng next/server sẽ tự dùng Edge API Route, dùng next sẽ dùng node api route. Nó chỉ có tác dụng nếu hosting lên nền tảng hỗ trợ edge function. VD vercel deploy sẽ tự hiểu và chạy edge api route trên máy chủ biên của họ. Nếu hosting trên nền tảng k hỗ trợ edge function sẽ k chạy được và phải convert về node api routes.
Thêm: export const config = { runtime: 'edge' }

Nó chỉ có ích nếu deploy trên nền tảng hỗ trợ edge api routes như vercel, aws, cloudflare. Nó triển khai trên máy chủ toàn cầu và dùng edge api route. 
Nếu deploy trên VPS sẽ k có edge api routes. Chú ý VPS là máy ảo, có thể cài VM trên lap cá nhân và host server sẽ gọi là 1 VPS.

-> URL custom api route: https://nextjs.org/docs/pages/building-your-application/routing/api-routes

-> import { geolocation, ipAddress } from '@vercel/functions'; 
Lấy ip và location của client ở phía server. Nó chỉ hoạt động khi deploy trên vercel.

-> res.setHeader("Cache-Control", "public, s-maxage=1200, stale-while-revalidate=600"); => kiểm soát cache của browser khi gọi trực tiếp vào api route.

-> pages/api/post/[...slug].js matches /api/post/a, but also /api/post/a/b, /api/post/a/b/c và có params { "slug": ["a", "b"] }
/api/post/[pid].ts => /api/post/abc sẽ cho req.query.pid = "abc"



# Dùng middleware
Mặc định middleware luôn chạy trên edge runtime. K thể dùng các nodejs module như fs, crypto, path, nhưng có thể dùng web api như fetch, NextResponse. Muốn dùng nodejs module hoặc là chuyển qua web api, hoặc phải tìm cách khác.
NextResponse giống Response của web thuần nhưng của nextjs để có thêm các hàm thao tác với redirect, rewrite, cookies, headers.

-> VD Tạo middleware.ts ở ngoài cùng cấp next.config.js (dùng cả page router và app router):
export function middleware(req, event) { return NextResponse.next(); }
export const config = { matcher: '/' };
=> Middleware chạy khi client request vào trang / (nếu k sẽ rất nhiều), chạy sau các setting trong next.config.js nếu ảnh hưởng, chạy trước khi trang được render

--> req.cookies.get, req.cookies.has, req.cookies, req.cookies.delete
--> Set thêm cookie vào response sau khi thực hiện xong với: const response = NextResponse.next(); response.cookies.set('name', 'value'); return response;
--> Set headers:
const response = NextResponse.next({
  headers: new Headers(req.headers);
}); 
response.headers.set('name', 'value'); 
return response;

-> VD: matcher: ['/about/:path*', '/dashboard/:path*'], => match mọi url /about/* và /dashboard/*
matcher: [
  {
    source: '/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',
    missing: [
      { type: 'header', key: 'next-router-prefetch' },
      { type: 'header', key: 'purpose', value: 'prefetch' },
    ],
  }
] => (?!...) là loại trừ các đường dẫn chứa, .* là match bất cứ ký tự nào với số lượng tuỳ thích. Với điều kiện là header phải k có 2 trường kia nữa.

=>*** Chú ý middleware nếu tự custom phải đủ url cả file ảnh nữa vì néu thiếu sẽ k load được ảnh

-> Middleware chỉ có 1 file nên muốn tách nhiều hàm xử lý với nhiều matcher khác nhau thì buộc phải nhét hết vào 1 matcher rồi tự check với req.nextUrl.pathname
VD: export function middleware(req: NextRequest, event: NextFetchEvent) {
  if (req.nextUrl.startsWith('/api/auth')) {
    event.waitUntil(
      fetch('https://my-analytics-platform.com', {
        method: 'POST',
        body: JSON.stringify({ pathname: req.nextUrl.pathname }),
      })
    )
    return middlewareA(req);
  }
  if (req.nextUrl.startsWith('/dashboard')) {
    return middlewareB(req);
  }
  return NextResponse.next();
}
export const config = {
  matcher: ['/api/auth/:path*', '/dashboard/:path*'],
};
=> event.waitUntil giúp thực hiện thêm task call api nếu cần.

-> redirect:
- import 2 hàm redirect và permanentRedirect để chuyển hướng ở server side từ next/navigation => chú ý k được bao try catch vì redirect nó internally throw error r
- client side dùng useRouter có
- redirects trong next.config.js sẽ chặn mọi request đến và redirect, thực hiện trước cả middleware, có option permanent true là permanent redirect
- NextResponse.redirect để redirect trong middleware, nó nằm sau redirects trong next.config.js

-> rewrites thì chỉ có trong next.config.js: đổi page mà k đổi url

-> Đổi url mà k đổi page với history.pushState({},"","/newurl");

-> Chain middleware:
- Có thê combine các middleware bằng cách viết logic từng cái liên tiếp trong 1 hàm middleware.js
- Middleware chỉ là 1 hàm nhận (request, event), rồi hoặc là trả ra response lấy từ NextResponse.next() cho client hoặc là redirect hay rewrites. Có thể tự tạo custom chain middleware gọi từng hàm một trả ra response, chia làm 2 loại, middlewares chạy trước và sau NextResponse.next()
URL code mẫu: https://www.youtube.com/watch?v=bFr2t68AABQ

->*** Chốt hiểu bản chất runtime và middleware:
NodeJS dùng 2 môi trường là node runtime và edge runtime. Node runtime truy cập được mọi api của nodejs. 
Edge runtime truy cập được 1 phần api thôi. Các api nó k truy cập được như native api của nodejs như path hay fs để đọc file, connect db. Nó k dùng được require mà chỉ dùng ES module, do đó thư viện ngoài dùng được miễn là thư viện đó k sử dụng native api của nodejs bên trong và dùng es module import thay vì require. 
Bản chất edge runtime thường dùng các hàm nhẹ, bộ nhớ giới hạn, tốc độ nhanh hơn. Node runtime xử lý hàm nặng nhưng tốc độ chậm hơn (cold start) vì phải chạy 1 server truyền thống để xử lý. 

Page router như getServerSideProps hỗ trợ cả edge runtime và node runtime dùng thoải mái nên k tính.
App router khuyên dùng edge runtime cho middleware. Còn node runtime thường dùng khi render application như trong route.js, layout.ts, page.ts
Trong thực tế, middleware bắt buộc dùng edge runtime, việc export runtime "nodejs" trong middleware k có tác dụng. Còn route.js, layout.ts, page.ts mặc định dùng node runtime, nếu export runtime "edge" trong các file này sẽ ép các file đó chỉ dùng api của edge runtime, cố dùng node runtime api sẽ lỗi.
VD khi dùng next-auth với database strategy nhưng database adapter k hỗ trợ edge runtime, mà dùng nó trong middleware sẽ lỗi, next-auth tự xử lý để adapter k hỗ trợ edge runtime tự k cho vào middleware.

Dùng runtime nào phụ thuộc 3 yếu tố: api dùng là gì, export runtime là gì, deploy lên đâu => vô cùng ez
export runtime như nào thì dùng đúng api trong phạm vi đó. Nhưng hầu hết các hàm của edge runtime đều có trong node runtime vì edge runtime bị hạn chế hơn.
Khi deploy vercel, nó tự phân tán trên toàn thế giới nhưng k cần chạy server mà tự chuyển mọi hàm trong edge runtime thành edge function, node runtime thành serverless function.
Khi deploy self-host nodejs server, nó dựng server và chạy tất cả như node runtime. Nhưng các hàm edge runtime sử dụng trong dự án hầu hết đều chạy được trên node runtime, chỉ các trường hợp hy hữu mới k được thôi.
=> Nếu tuân theo recommend của nextjs, middleware buộc dùng edge runtime, page.js và route.js dùng node runtime thì ta chả cần lo gì cả, deploy self host vẫn chạy được hết. Chỉ có 2 vấn đề: nếu middleware cần dùng nodejs api mà edge runtime k hỗ trợ, hoặc nếu case hy hữu xảy ra là dùng hàm edge runtime hiếm nào đó k chạy được ở node runtime. 
Giải pháp là chuyển đổi logic đó sang page.js server component thay vì xử lý ở middleware, hoặc tìm các api mà thực sự hô trợ, dùng rewrites redirects trong next.config.js thay vì middleware

-> export const config = {
  matcher: ["/((?!api|_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt|.*\\.png$|.*\\.jpg$).*)"]
}; => Bỏ tất cả /api/*, /_next/static, /_next/image, /favicon.ico, /sitemap.xml, /robots.txt mọi file kết thúc với .png và .jpg
=> Chú ý cần bỏ cả file ảnh để tránh sai



# NextJS i18n 
Có hàng loạt thư viện hỗ trợ hoặc dùng sẵn của nextJS: https://nextjs.org/docs/app/building-your-application/routing/internationalization
Lib @replexica/react giúp tự động dịch text bằng AI

Best practice => ref tới "SetupProjectnNextJS"
Mỗi lang có 1 route riêng. Dùng middleware check k có lang thì redirect lang mặc định.



#*** Hiểu client/server component
-> Client component được server chạy qua 1 lần, nhưng k chạy code useEffect. Nếu dùng window object trong client component trực tiếp sẽ lỗi, dùng conditional check cũng lỗi hydration vì html render ở server và client phải giống nhau. Dùng trong useEffect thì ok, FE sẽ bị jump giá trị khi useEffect chạy.
Để fix jump, có thể hiển thị loading nếu useEffect chưa chạy, đảm bảo chạy xong mới có data. Hoặc dùng suppressHydrationWarning ở tag html ngoài cùng sẽ bỏ báo lỗi client và server mismatch khi biết việc này là k thể tránh, nhưng k nên làm v.

--> Fix hydration error new Date() ở server: - K render time ra nữa
- Time k đóng vai trò gì trong SEO thì cho vào useState default "", set giá trị trong useEffect chỉ dùng ở client.
- Chỉ lấy đơn vị phút và giờ, k lấy second thì xác suất bị lỗi giảm nhưng kp là hoàn toàn. K có cách nào SEO cả time mà chuẩn từng giây được.

-> Kp file nào cũng cần "use client", 1 client component import 1 component khác thì component được import phải là client component, khi đó k cần "use client" ở file con. Chú ý client component cố tình import server comp gây lỗi.
Nhưng 1 client component có thể truyền { children } là 1 server component. Do đó thêm "use client" vào provider k biến cả app thành client component
VD: ta setup Provider của react-query là 1 client side component wrap 1 server component là layout.js, sau đó chỉ dùng các hàm react-query ở các client component bên trong ok.
Comp ngoài cùng luôn 1 server component, VD app/layout.ts
K có directive mặc định là 1 server component
Server component chỉ chạy trên server, nhưng client component chạy trên cả server (first rendering pass) và client.

--> Hack trick là dùng dynamic import có thể import server comp trong client comp. 
VD: 'use client'
import dynamic from 'next/dynamic'
import { Suspense } from 'react'
const ServerComponentExample = dynamic(() => import('./server-component'), {
  loading: () => <div>Đang tải...</div>,
  ssr: true // Quan trọng: render trước ở server
})
export default function ClientComponent() {
  return (
    <Suspense fallback={<div>Đang tải...</div>}>
      <ServerComponentExample />
    </Suspense>
  )
}



# next/forms
Cung component <Form/>, thường dùng cho server actions.

-> Dùng <Form> của next/form khi action là string: GET api, nó tự tối ưu prefetch, progressive enhancement và client-side navigate sang pages khác (kp reload)
replace={false} => true sẽ replace route k thể back về, false (default) sẽ push vào browser's history stack 
scroll={true} => default là true sẽ luôn scroll lên top của new route thay vì giữ vị trí scroll hiện tại
prefetch={true} => default là true sẽ prefetch khi visible trên viewport.

Dùng formMethod, formEncType, và formTarget cho form giống như method, encType, target sẽ khiến form quay trở về hoạt động như form bth của html => khi đó thà dùng <form> thường
Muốn post thì dùng server action, còn action là string sẽ navigate tới url đó kèm searchParams là nội dung form

-> Phân biệt:
1) HTML <form>: 
onsubmit trigger hàm khi ấn vào type="submit" hoặc dùng JS form.submit(), có reload page nếu không dùng e.preventDefault
action luôn nhận 1 string sẽ gửi request đến url đó kết hợp với method, enctype, target. Method get hay post đều redirect get tới url kia.
formAction dùng ở 1 button type "submit" thì khi ấn nó sẽ chạy như bth nhưng sẽ dùng url của formAction thay vì url gốc của form.
2) React form: giống html form.
Điểm khác biệt là có thêm onSubmit có thể nhận 1 hàm, sẽ trigger hàm. Sau đó thực hiện như behavior của form bth. 
VD nếu có cả action và onSubmit thì gọi onSubmit trước, nếu có e.preventDefault sẽ dừng luôn, nếu k có sẽ trigger tiếp redirect url trong action như html form
action là 1 hàm sẽ k redirect
3) Next form: giống react form. 
Điểm khác biệt là action nhận 1 hàm có thể call server action, còn onSubmit không được gọi hàm ở server mà là client side => nên ưu tiên chỉ dùng actions
Chú ý khi có formAction sẽ như html thuần và k còn support prefetching
4) <Form> của next/form: giống next form
Riêng case action là string GET sẽ hỗ trợ thêm prefetch và vài attribute replace, scroll, prefetch => chỉ dùng khi cần chuyển trang

--> Tuỳ biến nextjs: 
server component gọi 1 hàm async thì là gọi hàm ở server bth, k gọi được hàm của client. 
client component gọi hàm async sẽ mặc định là hàm của client side. Client component gọi hàm async "use server" trực tiếp (k cần qua form), gọi là server actions và gửi request tới server để thực hiện. 
Trong nextjs <Form> mà action là string thì dùng được trong server component, còn truyền vào hàm server thì nó phải nằm ở client component, nếu k sẽ lỗi.
Khi dùng server actions, hãy thêm "use server" ở function để tránh nó nhầm rằng client side tự gọi hàm phía client.
Chú ý file "use server" chỉ cho export các hàm là async

-> Các form hooks thường dùng chỉ dùng ở client component:
- useFormStatus cung status của last form submission: https://react.dev/reference/react-dom/hooks/useFormStatus
Dùng trong 1 client component (nằm trong 1 form) sẽ tự detect component hiẹn tại ở trong form nào và cung status của form đó:
const { pending, data, method, action } = useFormStatus();

- useFormState => deprecated thay bằng useActionState

- useActionState => dùng ở component chứa cái form để truyền vào form
const [data, submitAction, isPending] = useActionState(
  async (prevState, queryData) => {
    const itemID = queryData.get("itemID"); return { itemID };
  },
  { itemID: "" }
)
<form action={submitAction}>
  <input type="text" name="itemID" />
  <button type="submit" disabled={isPending}>Update</button>
</form>
=> Điều đb là k cần biết lưu state của input mà lấy được luôn trong hàm. Submit sẽ reset các trường của form, thêm defaultValue={data?.itemID} để cản điều đó, thực tế là reset về giá trị default là chính cái data lần cuối submit thôi. K lưu state, k render lại mỗi khi gõ vào
=> async (previousState: FormField, formData: FormData): Promise<FormField> vì previousState và return field phải giống nhau
=> Tham số 3 kbh dùng: https://www.youtube.com/watch?v=-aBKrvK5Vn8



# Custom code server nextjs => tốt nhất là k nên dùng
Dùng next start tự chạy server nodejs để serve dự án. Nếu chỉ tạo route api thì k cần vì nextjs có sẵn, nhưng muốn custom chi tiết thì vẫn được.
router.beforePopState
custom server làm mất đi nhiều tính năng tối ưu của nextjs và k thể deploy lên vercel, khi đó nên deploy lên VPS riêng => thay vì vậy, nếu cần server express riêng hãy tạo thêm 1 server rời.
NextJS hỗ trợ deploy nodejs nhưng sẽ chuyển hết thành serverless function. K hỗ trợ websocket mà phải dùng Ably, Pusher thay thế với cơ chế client lắng nghe event phát từ server

-> URL custom server: https://nextjs.org/docs/pages/building-your-application/configuring/custom-server
Tạo server.js ở ngoài cùng, chỉ có vài điểm khác là server liên kết với nextjs app qua: const next = require('next'); const app = next({ }); Và app server được tạo trong app.prepapre().then(<>) như bth
Phải chỉnh sửa cả package.json "node server.js" thay cho scripts dev và start

-> Disable file-system routing: Mặc định Next tuân theo cấu trúc folder pages để làm server nên nếu dùng custom server có thể disable nó với useFileSystemPublicRoutes: false => client route có thể vẫn access được và phải xử lý bằng navigation thủ công

-> server config:
export const config = {
  api: {
    // bodyParser: false, // auto enabled, muốn bỏ thì set false là được
    bodyParser: { 
      sizeLimit: '1mb', // maximum size allow for parsed body
    },
    // responseLimit: false, // automatically enabled và báo warning khi response quá 4mb
    responseLimit: '8mb', 
    externalResolver: true // flag báo rằng route này được xử lý bởi external resolver, it disables warnings for unresolved requests
  },
}



# Dùng lib vercel kv
Là lib giúp connect và tương tác với kv db provider. Chỉ dùng ở server side nên nếu client side muốn gọi phải tạo api cho client gọi.
Chỉ cần cài, setup biến .env là dùng được luôn.
VD có thể dùng cho redis local, hay redis upstash chỉ cần set biến .env
VD deploy lên vercel có thể link upstash redis vào project vercel cũng được.



# Feature flags
Giúp bật tắt feature mà k cần deploy lại code. 
Flag thường được lưu trong 1 file, hoặc 1 database. VD lưu vào 1 file để lên cloud S3 và lấy qua API, khi cần thì vào cloud sửa file settings là được.
User phải có quyền mới đổi dược flags.

-> Thư viện flag sdk của vercel chỉ giúp thao tác lấy flag dễ dàng thôi, ta vẫn lưu flag và db rồi lấy như bth được. Dùng rất đơn giản là tạo 1 file flag.ts lấy flag là xóng
Dùng hàm flag() của nó sẽ ép page thành dynamic rendering.
Hàm dedupe() của nó giống y cache của react tránh gọi lại nhiều lần

-> Thư viện toolbar của vercel giúp dùng toolbar của vercel ngay trong app để edit config flag ngay trên toolbar được.
Dùng @vercel/toolbar yêu cầu phải link project với vercel và deploy lên vercel, tạo FLAG_SECRETS nữa
URL: https://www.youtube.com/watch?v=M1Rj1xSm3SM\



# Handle error
-> Server actions: k cần dùng try catch, cứ viết 1 hàm async bth, sau đó nhét vào useFormState (với react18) or useActionState (react19)
const [state, formAction] = useFormState(createUser, initialState)
=> state sẽ tự trả về error message với state.message

-> Server components: 
const res = await fetch(`https://...`)
const data = await res.json()
if (!res.ok) {
  return 'There was an error.'
}
Nhưng kp api nào cũng trả ra như v. Vd server component page có 1 server component con call db bị lỗi throw khiến component con k render, page render error.tsx, trong khi chỉ muốn hiện lỗi cho 1 component con thôi. Thì buộc phải try catch component hiện theo ý ta

-> Unexpected error
Dùng error.js với error ở từng route (thật ra error sẽ bubble up lên parent từ từ), dùng global-error.js với error trong root layout
error.js là client side comps.
Còn global error sẽ replace tất cả root hay layout. Nếu có error mà error.ts k bắt thì global-error sẽ bắt.



# Hiện loading khi server fetching
VD khi chuyển page thì thì chạy getServerSideProps phải chờ thì nên hiện loading

-> App router dùng Suspense fallback thì server component khi load api sẽ tự hiện. Hoặc viết loading.js sẽ load ở cấp độ page.js, nếu page.js call api hoặc server child component call api mà k có boundary thì boundary ngoài cùng cũng bắt.
Có thể trigger Suspense boundary trong React Developer Tools.
Dùng loading là nextjs tự động streaming rồi, BE cứ gửi cho FE hiện loading trước, component server xử lý xong sẽ streaming gửi cho client thay thế Suspense fallback thoi.

-> Với pages routes: K thể bắt được getServerSideProps để loading phía client nhưng có thể bắt sự kiện đổi router với Router.events nhưng sẽ k ổn vì mọi component trong page sẽ bị rerender khi hiển thị thanh loading ở giữa page. Hơn nữa khi k cần loading mà bất cứ khi nào router đổi k chạy getServerSideProps thì nó vẫn chạy loading k cần thiết
=> Lib NProgress sẽ tạo loading hiển thị cục trên mà k rerender lại các components page nên vẫn ok, dùng với Router.events => ref tới "Projects / MoveWorld"



# Dùng view transition API
URL: https://www.youtube.com/watch?v=xfzNXa8WYW8

Animate bằng clip path khi 1 page xuất hiện đẹp hơn là cho nó di chuyển từ ngoài vào
Trong js có hàm tag.animate giúp animate bằng JS cho 1 tag dễ như @keyframe của css

-> Chốt v15 view transition api: 
C1: Dùng như html thuần
C2: Thêm nextconfig và dùng unstable_ViewTransition của react bao từng thẻ trường name như <ViewTransition name>  thay thế view-transition-name. 
=> Cả 2 cách với MPA đều hoạt động k chuẩn, lúc được lúc không.



# PWA
-> Home screen icon: Tạo file manifest là xong.
Web chuyên tạo icon: https://realfavicongenerator.net/

-> NextJS có cả server nên tạo web push notification hoàn chỉnh được.
URL từng bước: https://nextjs.org/docs/app/building-your-application/configuring/progressive-web-apps



# Other
-> Setup dùng các tool test cypress hay jest: https://nextjs.org/docs/pages/building-your-application/testing/jest

-> Debug server side: Chạy "NODE_OPTIONS='--inspect' npm run dev" -> mở browser chrome://inspect/#devices tương tự nodejs

-> Chỉ số TTI và FID: TTI là Time To Interactive đo từ lúc trang bắt đầu tải cho đến khi có khả năng xử lý sự kiện của người dùng. FID là First Input Delay đo ktg chờ đợi từ khi user tương tác đầu tiên cho đến khi trang phản hồi tương tác đó
URL: https://pagespeed.web.dev/ giúp đo tốc độ của trang web và các thông số giống tool light house

Khi có 1 landing page dài viết bằng nextjs thì khi gõ url r ấn enter, phía client side sẽ:
1) HTML được load xuống browser sau khi server chạy SSR xong
2) JS được tải xuống browser r thực thi
3) JS chạy xong sẽ gắn đống event vào cây DOM
=> Bước 2 và 3 là 2 bước hydrate JS khiến cho TTI và FID cao, web tuy được mở ra nhưng người dùng vẫn chờ lâu mới tương tác được. Bước 1 là thời gian hiện khoảng trắng lâu do server fetch API ngoài để điền vào HTML.

Mặc định next nó luôn tuân thủ 3 bước đó. Nhưng thực tế, trong TH trang landing page toàn component tĩnh ít tương tác với user hoặc có tương tác nhưng ít mà ta muốn chơi kiểu "chỉ khi component đó hiển thị ra cho user thì mới cần hydrate để tương tác được JS" thì vẫn có thể optimize được:
- Thư viện react-hydration-on-demand giúp mọi phần code JS vẫn được download và parsed ở bước 2 như bth nhưng đến bước 3 chỉ thực hiện khi component đó visible trên màn hình
- Lib next-lazy-hydrate giúp cả phần download, parsed và executed JS chỉ thực hiện khi component visible
=> Người dùng muốn tương tác sẽ lâu hơn 1 tí ở trang landing page nhưng tốc độ load trang và performance rất nhanh.
=> Dùng dynamic import khác là nó sẽ delay cả 3 bước cho đến khi component được render trên DOM tree chứ k chỉ visible.

-> Tổng kết tối ưu SEO và performance NextJS => ref tới "Projects / MoveWorld"
Thiết kế placeholder sao cho k có layout shift ở mọi màn hình cả text và ảnh.
Thuộc tính priority của Image có tác dụng xđ hình ảnh ưu tiên cần tải trước các hình khác trên trang. Nên dùng <Image/> với local image hơn là url để next tối ưu và tự động có lazy loading. Dùng onError và blurData tạo hiệu ứng. 
Tối ưu hóa ảnh và font trong docs nextjs, tải hẳn về chứ k dùng API.
Setup SEO với DefaultSeoTag và đầy đủ mọi thẻ Head ở từng trang. Dùng đủ các thẻ canonical và open-graph, chuẩn bị các ảnh cho thẻ preload thumbnail khi nhúng vào web khác. 
Tối ưu dùng JS và css thuần, xóa bỏ các file không dùng. Dùng tree-shaking cho mọi thư viện, nên dùng ít thư viện nhất có thể và nên tự implement (check bằng webpack-bundle-analyzer), hoặc đổi sang thư viện nhẹ hơn.
Dùng dynamic import cho các phần tử k chắc chắn dùng luôn khi vào page (React thì là React.lazy). Nên dùng thẻ Link của nextjs để tận dụng prefetch hoặc router.prefetch(url) thủ công.
Dùng getStaticProps nhiều nhất có thể, dùng getServerSideProps với request nhẹ lấy data chỉ cần cho SEO thôi, k cần quá realtime thì nên dùng revalidate + getStaticProps, lại còn tận dụng được prefetch có sẵn của nextjs nữa.
Nên host trên CDN khi dùng static page. Nếu dùng vercel hosting thì có thể đảm bảo mọi thứ đều ổn.

-> nextjs có config next.config.js để build ứng dụng như Preact, bundle size sẽ nhỏ hơn react nhưng code thì y như react, 1 số tính năng mới của react sẽ k chạy => k dùng vì sửa webpack phức tạp.

-> Vercel có web analytics là package cho vào dự án để theo dõi lượt view ok. Tương tự có vercel speed insight.

