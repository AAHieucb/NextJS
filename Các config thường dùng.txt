-> const rawCookie = await cookies();
rawCookie.set("lang", lang, {
  httpOnly: true,
  path: "/",
  sameSite: "strict",
  secure: true,
  maxAge: 31536000,
  priority: "medium"
});



-> schema.ts:
const UserTable = pgTable("test", {
  id: uuid().primaryKey().defaultRandom(),
  email: text("email").notNull().unique(), // text k có tham số tự tạo cột trùng với tên trường
  role: pgEnum("user_roles", ["admin", "user"])().notNull().default("user"),
  createdAt: timestamp("created_at"), // tạo cột tên là created_at kiểu TIMESTAMP trong SQL
  updatedAt: timestamp({ withTimezone: true }).notNull().defaultNow().$onUpdate(() => new Date()),
});
pgTable("user_oauth_accounts", 
  {
    userId: uuid().notNull().references(() => UserTable.id, { onDelete: "cascade" }),
    providerAccountId: serial("id"), // serial là số int tự động tăng dần
    count: integer()
  },
  t => [primaryKey({ columns: [t.providerAccountId, t.userId] })]
)



-> drizzle.config.ts:
export default defineConfig({
  schema: "./src/utils/drizzle/schema.ts", // Nơi ta code file schema
  out: "./src/utils/drizzle/migrations", // Nơi sinh ra code migration
  dialect: "postgresql",
  driver: "pglite",
  introspect: {
    casing: "camel", // default, lúc query column có thể dùng camel key dù cột trong db thực chất là preserve, nó sẽ tự convert chuẩn
  },
  dbCredentials: {
    host: "db.example.com",
    port: 5432, // Default PostgreSQL port
    user: "my_user", // Database username
    password: "my_secure_password", // Database password
    database: "my_database", // Database name
    ssl: "require", // Enforce SSL connection, còn true là chỉ đơn giản bật SSL, nhưng không kiểm tra chứng chỉ.
    ssl: { // or
      rejectUnauthorized: false,
    },
    url: process.env.DATABASE_URL!, // or // truyền 1 URL phải có password
  },
  verbose: true, // Hiện rõ mọi sql statement khi dùng drizzle-kit push
  strict: true, // Nếu thay đổi db mà sai trường, k có default value, xoá table thì phải đưa ra cảnh báo
});

--> driver: "pglite" => Nếu có dialect, thường để driver trống sẽ tự lấy chuẩn theo dialect. 
VD tự xác dịnh pglite là chạy postgre trên browser và nodejs, driver này sẽ dùng package nhẹ để tạo in-memory db. Khi đó phải set dbCredentials là url tới folder lưu db.



-> tsconfig.json:
{
  "compilerOptions": {
    "target": "ES2017", // *Specifies the target JavaScript version. VD 'es5' for ECMAScript 5; "es6" for ecmascript 6
    "lib": ["dom", "dom.iterable", "esnext"], // *Specifies the library files to be included in the compilation. "es2015" fix lỗi promise, "dom" fix lỗi console
    "allowJs": true, // *Allows JavaScript files to be compiled.
    "skipLibCheck": true, // *Skips type checking of declaration files.
    "strict": true, // *Enables all strict type-checking options.
    "noEmit": true, // *Disables emitting files from the compilation.
    "esModuleInterop": true, // *Enables interoperability between CommonJS and ES Modules, sẽ giúp việc import các mô-đun trở nên mượt mà hơn.
    "module": "esnext", // *Specifies the module code generation: 'esnext' for modern JavaScript modules. "commonjs" là tiêu chuẩn cho nodejs.
    "moduleResolution": "bundler", // *Determines how modules are resolved. VD 'node' mimics Node.js module resolution. 
    "resolveJsonModule": true, // *Allows importing JSON files as modules.
    "isolatedModules": true, // *Đảm bảo mỗi file được xử lý như 1 module, compile độc lập k dựa vào file khác. Tức phải có ít nhất 1 export, k có sẽ báo lỗi.
    "jsx": "preserve", // *Preserves JSX as part of the output.
    "incremental": true, // *Enables incremental compilation for faster builds.
    "removeComments": true, // *Removes comments from the output.
    "preserveConstEnums": true, // Typescript có enum sang JS chuyển thành số. Config giữ `const enum` declarations in the output.
    "alwaysStrict": true, // *Ensures 'use strict' is always emitted.
    "strictNullChecks": true, // *Ensures `null` and `undefined` are only assignable to themselves and `any`.
    "noUncheckedIndexedAccess": true, // Adds `undefined` to the type of an indexed access when the index signature is not present.
    "noImplicitAny": true, // *Raises an error on expressions and declarations with an implied `any` type.
    "noImplicitReturns": true, // *Raises an error on functions that do not return a value in all code paths.
    "noImplicitThis": true, // *Raises an error on `this` expressions with an implied `any` type.
    "noUnusedLocals": true, // *Raises an error on unused local variables.
    "noUnusedParameters": true, // *Raises an error on unused parameters.
    "allowUnreachableCode": false, // *Disallows unreachable code.
    "noFallthroughCasesInSwitch": true, // *Disallows fallthrough cases in switch statements.
    "outDir": "out", // *Redirects output structure to the directory.
    "declaration": true, // *Generates corresponding `.d.ts` files.
    "sourceMap": true, // *Generates source map files.
    "allowSyntheticDefaultImports": true, // *Cho import từ module k có default export. VD import React from "react"; Nếu k có buộc phải dùng: import * as React from "react";
    "forceConsistentCasingInFileNames": true, // *Disallows inconsistently-cased references to the same file.
    "watch": true, // thay đổi file ts tự compile lại
    "baseUrl": ".", // *Specifies the base directory to resolve non-relative module names.
    "paths": { => baseUrl kèm paths để thêm tiền tố
      "@/*": ["./src/*"], // Maps `@/*` to `./src/*` for module resolution.
      "@/public/*": ["./public/*"] // Maps `@/public/*` to `./public/*` for module resolution.
    }
  },
  "exclude": ["./out/**/*", "./node_modules/**/*", "**/*.cy.ts"], // Excludes specified files and directories from the compilation.
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"] // Includes specified files and directories in the compilation.
}



-> next.config.mjs (v15.2):
poweredByHeader: false, // *NextJS sẽ k thêm header "X-Powered-By: Next.js" vào các response HTTP, ẩn thông tin bảo mật
logging: { fetches: { fullUrl: true } } => *Log thông tin full URL khi fetch API bằng "fetch" của nextjs ở dev mode.
basePath: '' => *default load static files từ folder public. Set tự động có url prefix ở trước, mặc định là rỗng. VD: basePath: '/docs' thì <Link href="/about"> sẽ cho ra <a href="/docs/about">
trailingSlash: true => có / ở cuối kqtr
reactStrictMode: true, => bỏ, dùng app router tự có true luôn
images: { => *
  loader: "custom", // Dùng custom loader
  loaderFile: "./loader-img.ts", // File export ra function nhận { src, width, quality } trả ra 1 url ảnh đã được optimize. VD dùng cloudinary sẽ rõ
  unoptimized: true,
  remotePatterns: [
    {
      protocol: "https",
      hostname: "images.unplash.com", // or ** là tất cả
      port: "",
      pathname: "/**",
      search: "", // để trống thì url ảnh k được có search params nào cả mới optimize
    },
  ],
  domains: [ // y hẹt remotePatterns nhưng k dùng wildcard mà fix cứng
    "aptos-api-testnet.bluemove.net",
    "aptos.dev",
  ],
  minimumCacheTTL: 60, // Image luôn tự được cache, có thể set TTL như này, nó sẽ ss với Cache-Control header và lấy cái lớn hơn.
  deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840], // Default
  imageSizes: [16, 32, 48, 64, 96, 128, 256, 384], // Default.
},
useFileSystemPublicRoutes: false, => k chia router theo cấu trúc thư mục nữa, phải tự custom server để serve.
eslint: {
  dirs: ['.'], => *eslint kiểm tra toàn bộ thư mục hiện tại, mặc định check trong src thôi là chuẩn rồi, chứ set như này check cả .next nữa là sai
}, 
appDir: true, => dùng app router => bỏ, tự dùng là được chứ k cần nx
serverActions: true, => bỏ, v13 mới cần thôi
serverActionsBodySizeLimit: '2mb', => v13
serverActions: {
  bodySizeLimit: '2mb', => v14 trở đi phải dùng như này, default 1mb
}
staleTimes: { => Phải có mới enable client-side router cache cho pages
  dynamic: 30, // default 0s tức nó k cache page dynamic
  static: 180, // default 5p là nó luôn cache page static, hoặc khi prefetch 1 page vào cache khi dùng <Link prefetch={true}/> hoặc gọi router.prefetch
},
bundlePagesRouterDependencies: true, => *bundle các page router dependencies trong quá trình build giúp tối ưu hiệu suất và kích thước, luôn dùng
serverExternalPackages: ['lodash', 'axios'], => Các packages mà server k bundle mà sẽ lấy từ node_modules trực tiếp, qtr build nhanh hơn nhưng size lớn hơn.
esmExternals: false => default true cho phép nextjs sử dụng cách gọi EcmaScript Module (export import) bên ngoài mà k cần chuyển đổi sang CommonJS (module.export require). Nếu là false thì nó phải chuyển hết các gói ESM về commonjs nên build sẽ lâu hơn
experimental: { }
devIndicators: { => liên quan đến việc hiển thị các chỉ số trong quá trình chạy app. 
  buildActivity: false, => k hiện các chỉ số khi build như khi tái biên dịch, trông clear hơn nhưng khó khăn hơn khi debug
},
output: "export" => sẽ "export" ra chỉ file static để host CSR thôi, "standalone" sẽ trích tất cả các file cần thiết từ mọi nơi ra tối ưu và chạy minimal server đó là được
async headers() { => set custom header
  return [
    {
      source: '/:path*',
      headers: [
        {
          key: 'x-hello',
          value: 'there',
        },
      ],
    },
    {
      source: '/blog/:slug',
      headers: [
        {
          key: 'x-slug',
          value: ':slug', // Matched parameters can be used in the value
        },
        {
          key: 'x-slug-:slug', // Matched parameters can be used in the key
          value: 'my other custom header value',
        },
      ],
    }
  ]
},
async rewrites() {
  return [
    {
      source: '/old-url',
      destination: '/new-url', // URL thực tế sẽ được xử lý
    },
    {
      source: '/api/:path*',
      destination: 'https://api.example.com/:path*', // Proxy đến một API khác
    },
  ];
},
async redirects() {
  return [
    {
      source: '/blog/:slug',
      destination: '/news/:slug',
      permanent: true,
    },
  ]
},
assetPrefix: "https://cdn.mydomain.com",
cacheHandler: require.resolve('./cache-handler.js'),
cacheMaxMemorySize: 0, => disable default in-memory cache để dùng theo cacheHandler
generateBuildId: async () => { return "xxx"; },
compress: true,
crossOrigin: 'anonymous', => sẽ thêm vào script tag crossOrigin="anonymous" hoặc crossOrigin="use-credentials"
experimental: {
  viewtransition: true,
  reactCompiler: true
}

--> compress: Mặc định true và nextjs nén với gzip. Khi host trên vercel, nó dùng brotli trước r mới gzip. Check loại thuật toán trong Accept-Encoding và Content-Encoding header
Muốn đổi thuật toán phải tự cài và disable compress mặc định của nextjs. VD set nginx compress với brotli và disable compress của nextjs để chỉ dùng của nginx.

--> generateBuildId: mặc định mỗi lần build sẽ gắn với 1 build id mới được sinh ra. 2 lần build cùng build id sẽ tận dụng build cache của lần build trước và chạy cực nhanh, nếu khác build id sẽ xoá cache build lại từ đầu. 
Nếu ta cần rebuild mà k sửa code, VD sửa env var và build lại thì nên dùng cùng build id cho nhanh. Lý tưởng nhất là gắn buildid là githash để đảm bảo code đổi mới thực sự xoá build cache. Thường sử dụng để build dự án cho nhiều môi trường khác nhau nhanh chóng.

--> cacheHandler: mặc định cache được lưu in-memory max 50MB, nhưng nếu host lên container platform như K8s thì mỗi pod sẽ có 1 cache rời rạc k đồng nhất. cacheHandler giúp tạo 1 cache consistent duy nhất, có thể dùng S3 or redis tuỳ. Dùng nó sẽ opt out in-mem cache bth và dùng cache trong file này.
URL: https://nextjs.org/docs/app/building-your-application/deploying#configuring-caching
Dùng cái này vẫn đạt hiệu quả y như in-mem cache (chậm hơn tí), nó xử lý cache và ISR luôn.

--> assetPrefix là url của cdn host static file nếu ta muốn host server riêng, static file ra CDN riêng thì phải thêm vào. Thì mọi request tới /_next/static/chunks/ sẽ thành https://cdn.mydomain.com/_next/static/chunks
Sau khi build, host phần .next/static lên CDN. Nó bao gồm các file js css chunk static, k tính file trong thư mục public, nếu folder public cũng CDN thì phải thêm settings khác.

--> images.deviceSizes: Nếu biết trước các loại máy sử dụng thì để vào để tránh image optimizer phải optimize quá nhiều.
images.imageSizes: Set image width, nối với deviceSizes tạo full array. imageSizes chỉ dùng cho image có prop sizes, chỉ rằng image nhỏ hơn full-width của screen.



-> posstcss.config.js
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {}, // => nextjs có r, nhưng tự tạo file postcss.config sẽ ghi đè bị mất phải tự thêm lại
    ...(process.env.NODE_ENV === "production" ? { cssnano: {} } : {}), // cssnano: {} và cssnano: {preset: "default"} là giống nhau
  },
  plugins: [ // or
    "tailwindcss",
    "postcss-flexbugs-fixes",
    [
      "postcss-preset-env",
      {
        "autoprefixer": {
          "flexbox": "no-2009"
        },
        "stage": 0,
        "features": {
          "custom-properties": false,
          "nesting-rules": true
        }
      }
    ]
  ]
};
  


-> .prettierrc:
{
  "singleQuote": false, => *
  "printWidth": 100, => *1 dòng max 100 ký tự
  "importOrder": ["^@core/(.*)$", "^@server/(.*)$", "^@ui/(.*)$", "^[./]"], => thứ tự sx nhóm các câu lệnh import
  "importOrderSeparation": true, => thêm 1 dòng trống giữa các nhóm import khác nhau được define từ importOrder
  "importOrderSortSpecifiers": true, => tự sx tên biến và hàm trong 1 câu lệnh import theo thứ tự alphabet
  "tabWidth": 2, => *
  "semi": true, => *buộc có dấu ; cuối mỗi câu lệnh
  "trailingComma": "es5", => thêm dấu phẩy cuối cùng ở các cấu trúc hỗ trợ ES5 (như array, object, v.v.).
}



-> .eslintrc.json v1:
{
  env: {
    browser: true, // Cho phép dùng API của trình duyệt (FE)
    node: true, // Cho phép dùng API của NodeJS (BE). VD nếu chỉ dùng FE thì bỏ đi
    es2021: true, // Hỗ trợ tính năng JS từ ECMAScript 2021 trở xuống.
  },
  "globals": {
    "arguments": true, // List các global var dùng trong dự án, nếu không khi truy cập vào biến global, eslint sẽ báo lỗi truy cập biến chưa định nghĩa, list toàn bộ biến global ra. VD window, document không cần định nghĩa lại vì tự có sẵn r. VD dùng "arguments" trong hàm thì phải có.
  },
  settings:{ // settings là giá trị mà plugins sử dụng 
    react: {
      version: "detect", // Tự động xác định react version trong dự án để format react. Hoặc chỉ định rõ version: "18.3"
    },
  },
  "plugins": [ // Dùng các plugins mở rộng thêm cho eslint 
    "import", // Tránh import thừa, sai thứ tự
    "react", // Thêm quy tắc cho react.
    "@typescript-eslint", // ESLint check typescript chính xác hơn
    "prettier", // K chuẩn prettier, eslint cũng báo lỗi.
    "react-refresh", // Kích hoạt plugin React Refresh trong ESLint, dùng hỗ trợ Fast Refresh.
  ],
  "parserOptions": {
    "ecmaVersion": 13, // Hỗ trợ check cho phien bản ES2022, nên dùng "latest"
    "sourceType": "module", // "script" là k dùng imort/export, module là có
    "ecmaFeatures": {
      "jsx": true, // Kích hoạt JSX trong ESLint, làm việc với React thì cần
    }
  },
  // Áp dụng mọi file
  "extends": [ // Kế thừa các quy tắc mặc định từ các cấu hình ESLint có sẵn 
    "next/core-web-vitals", // *Sử dụng bộ quy tắc chính thức từ Next.js, tránh các warning lỗi vớ vẩn
    "plugin:prettier/recommended", // *Khuyên dùng nếu có prettier
    "eslint:recommended", // extends có config có sẵn recommended mà ta có thể dùng
    "plugin:react/recommended",
    "prettier", // Tắt các quy tắc ESLint có thể xung đột với prettier, phải cài package eslint-plugin-prettier, hoặc dùng trong rules như dưới
    "plugin:react/jsx-runtime", // Kế thừa quy tắc jsx runtim, VD k cần import React ở đầu mỗi file jsx
    "plugin:react-hooks/recommended", // Áp dụng các quy tác khuyến nghị của react hook
  ],
  "rules": { => Ghi đè hoặc thêm các quy tắc tùy chỉnh.
    "prefer-const": "error", // Buộc dùng const thay vì let nếu biến k được gán lại
    "quotes": ["error", "double"] // *Buộc dùng " thay vì ' 
    "prettier/prettier": [ // tích hợp prettier với eslint rule, phải cài package eslint-plugin-prettier 
      "error",
      {
        "singleQuote": true,
        "endOfLine": "auto", // auto tự động điều chỉnh ký tự xuống dòng phù hợp với OS, window là \r\n, linux là \n
      }
    ],
    "react-refresh/only-export-components": "warn", // warn nếu có export không phải là component React trong một file chứa JSX. 
  },
  // Quy định cấu hình riêng cho các loại file khác nhau
  "overrides": [ 
    {
      "files": ["**/*.ts", "**/*.tsx"],
      "plugins": ["@typescript-eslint"], // *Kích hoạt plugin @typescript-eslint, cung cấp các quy tắc hỗ trợ kiểm tra mã TypeScript.
      "extends": [
        "plugin:@typescript-eslint/recommended", // *Kế thừa các quy tắc kiểm tra TypeScript tốt (do nhóm TypeScript ESLint cung cấp).
        "prettier" // *Tắt các quy tắc ESLint có thể gây xung đột với Prettier để cả 2 hoạt động ok, phải có package eslint-config-prettier
      ],
      "parserOptions": {
        "project": "./tsconfig.json" // *
      },
      "rules": { // rules riêng cho kiểu file này
        "react-hooks/exhaustive-deps": "off", // *Vô hiệu hóa cảnh báo về thiếu dependency trong useEffect
        "@typescript-eslint/ban-ts-comment": ["warn", "off"], // *Vô hiệu hóa cảnh báo khi sử dụng chú thích @ts-ignore
        "react-hooks/rules-of-hooks": "off", // *Vô hiệu hóa kiểm tra các rules-of-hooks
        "quotes": ["error", "double"], //*
        "semi": ["error", "always"], //*
        "@typescript-eslint/no-unused-vars": "off",
        "no-unused-vars": ["error"],
        "no-unused-vars": [ // or
          "warn",
          {
            vars: "all",
            varsIgnorePattern: "^_$", 
            argsIgnorePattern: "^_$", 
            ignoreRestSiblings: true, 
          },
        ],
        "no-mixed-spaces-and-tabs": ["error", "smart-tabs"], // space và tabs k được mix, nếu mix thì tab dùng để indent, space để căn chỉnh thôi.
        "react/jsx-uses-react": 2, // phải import React khi dùng component jsx, nếu k sẽ báo lỗi
        "indent": [2, 2, { "SwitchCase": 1 } ], // Lùi dòng là 1 tab hoặc 2 spaces, nếu là switchcase thì chỉ 1.
        "linebreak-style": ["error", process.platform === "win32" ? "windows" : "unix"], // dùng đúng kiểu xuống dòng. off(0), warn(1), error(2)
        "curly": [2, "all"], // Phải có {} chứ k được bỏ nhanh như kiểu if else
        "camelcase": ["error", { "properties": "always" }], // K dùng camelCase sẽ báo lỗi
        "eqeqeq": [2, "smart"], // Phải dùng === or !== khi so sánh. "smart" tức là trừ các TH ss với typeof, literal value, ss với null thì k cần
        "one-var-declaration-per-line": [2, "always"], // 1 dòng chỉ được khai báo 1 biến.
        "new-cap": [2, { "capIsNew": true }] // new Constructor phải viết hoa tên Constructor
        "no-case-declarations": 0 // let const function class khai báo trong case của switch case thì phải có { } bao case đó. var thì thoải mái
	      "no-empty": "warn", // Cảnh bảo nếu {} bị bỏ trống bên trong {}
        "no-prototype-builtins": "off", // default, k cảnh báo khi dùng hasOwnProperty, isPrototypeOf, propertyIsEnumerable, chỉ là để tránh ghi đè phương thức gốc
        "react/prop-types": "off", // default, k cảnh báo khi dùng react component mà k có props type, dùng typescript thì tự có type mà k cần propTypes làm gì.
      }
    }
  ]
}

-> esling.config.js:
import js from '@eslint/js'
import globals from 'globals'
import react from 'eslint-plugin-react'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
export default [
  { ignores: ['dist'] }, // bỏ qua folder dist
  {
    files: ['**/*.{js,jsx}'], // cấu hình cho các file js và jsx
    languageOptions: {
      ecmaVersion: 2020, // cú pháp ECMAScript 2020
      globals: globals.browser, // cung cấp biến toàn cục cho môi trường browser
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true }, // cú pháp jsx
        sourceType: 'module', // cho phép mã nguồn dùng import/export (ES Modules).
      },
    },
    plugins: {
      react, // check các quy tắc chung của react
      'react-hooks': reactHooks, // đảm bảo react hook dùng đúng cách
      'react-refresh': reactRefresh, // hỗ trợ Hot Module Replacement (HMR) với React Refresh
    },
    rules: {
      ...js.configs.recommended.rules, // Xác định các rules recommend
      ...react.configs.recommended.rules,
      ...react.configs['jsx-runtime'].rules,
      ...reactHooks.configs.recommended.rules,
      'react/jsx-no-target-blank': 'off', // K cảnh báo khi dùng target="_blank" mà không có rel="noopener noreferrer".
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true }, // Cho phép export các giá trị hằng số.
      ],
    },
  },
]

-> eslint.config.mjs v2:
const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript", "prettier"),
  {
    rules: {
      quotes: ["error", "single"],
      "@typescript-eslint/no-unused-vars": "off",
    },
  },
];



-> package.json:
{
  "name": "codeagain",
  "homepage": "static", // url relative để load file static, k set nó bị lỗi trang trắng tinh khi mở index.html sau khi build đó
  "description": "test",
  "main": "index.html", // xđ file chính của dự án bắt đầu chạy. Nếu k có thì Node.js mặc định tìm index.js ở thư mục gốc. 
  "keywords": ["a","b","c"],
  "version": "0.1.0",
  "author": "John Doe <john.doe@whatever.com> (https://whatever.com)",
  "license": "MIT", // ISC, GPL-3.0
  "author": { // or
    "name": "John Doe",
    "email": "john.doe@whatever.com",
    "url": "https://whatever.com"
  },
  "author": "trava.finance", // khi là tên tổ chức chung
  "contributors": [ // Có thể nhiều người đóng góp nhưng chỉ 1 tác giả, contributors và author đều chỉ dùng khi publish package lên npm thôi
    {"name":"Johan","url":"https://github.com/johanjordaan"},
    {"name":"Christopher John Ryan","email":"chrisjohnryan@live.com","url":"https://github.com/ChrisJohnRyan"}
  ]
  "private": true, // dự án sẽ k được publish như 1 package lên npm registry
  "bugs": "https://github.com/whatever/package/issues" // Đường dẫn đến trang issues của package.
  "repository": "bitbucket:whatever/testing", // nơi lưu source code
  "repository": { // or
    "type": "git",
    "url": "https://github.com/bnb/metaverse.git"
  },
  "engines": { // xđ phiên bản nodejs mà ứng dụng đang hoạt động nếu sợ publish lên npm rồi user dùng version node quá thấp để cài
    "node": ">= 6.0.0",
    "npm": ">= 3.0.0",
    "yarn": "^0.13.0"
  },
  "browserslist": ["> 1%", "last 2 versions", "not ie <= 8"],
  "scripts": {
    "lint": "next lint", // check rules eslint và show cảnh báo 
    "lint": "eslint src --ext .ts,.tsx", // or
    "format": "prettier --check --ignore-path .gitignore .", // check rules prettier và show cảnh báo
    "format:fix": "prettier --write --ignore-path .gitignore .", // check và fix rules prettier
    "prepare": "husky install"
  },
  "lint-staged": { // Kết hợp husky, khi commit sẽ tự fix format các file đã được staged
    "*.{js,jsx,ts,tsx}": [
      "eslint --fix" // --fix để tự động fix nếu có lỗi
    ],
    "*.{ts,js,jsx,ts,tsx,json,yml}": [
      "prettier --write"
    ]
  },
  "dependencies": {
  },
  "devDependencies": {
  },
  "proxy": "http://localhost:3000"
}

--> "browserslist": ["> 1%", "last 2 versions", "not ie <= 8"], => là hỗ trợ 2 phiên bản chính cuối cùng của tất cả các trình duyệt với ít nhất 1% mức sử dụng ngoại trừ IE8 trở xuống. 
Nó xđ các phiên bản trình duyệt hỗ trợ, rồi nó sẽ được tham chiếu bởi babel, autoprefixer và các tool khác để thêm polyfills và các thứ cần thiết để chạy. Chỉ có tác dụng khi dự án chạy ở browser.

--> version: x.x.x thì <phiên bản chính>.<phiên bản phụ>.<phiên bản vá lỗi>
Trong 1 release chỉ sửa lỗi bản vá, nếu giới thiệu những thay đổi backward-compatible là một bản phát hành nhỏ, 1 bản phát hành lớn sẽ khiến API cũ k còn hoạt động.

--> dependencies: 
~ là cập nhật mọi bản vá lỗi luôn. VD: ~0.13.0 sẽ update các bản vá 0.13.1 nếu có nhưng k có 0.14.0
^ sẽ cập nhật mọi bản vá lỗi và cập nhập phụ như 0.14.0, 0.13.2 ok hết => phổ biến nhất
* cập nhật tất cả phiên bản
> cập nhập phiên bản cao hơn ta chỉ định or >= là cao hơn or bằng. Tương tự < và <=
x.x.x fix cứng duy nhất phiên bản này
lastest luôn dùng phiên bản newest -> k nên vì cú pháp code cũ có thể break
^1.0.0-beta.52 => có thể tính các phiên bản rc hay test alpha beta
1.0.0 || > = 1.1.0 < 1.2.0 => kết hợp toán tử để sử dụng 1.0.0 hoặc 1 bản phát hành từ 1.1.0 trở lên nhưng nhỏ hơn 1.2.0



-> .commitlint.config.js:
{
  extends: ['@commitlint/config-conventional'] // commit message dựa theo chuẩn commit của Angular 
}



-> .eslintignore:
node_modules
out
.next
/build/**
!.eslintrc.js



-> .prettierignore:
**/node_modules/**/*
out
yarn.lock
package-lock.json
**/*.svg
package.json
.eslintignore
*.png
*.toml
.gitignore
.prettierignore
LICENSE
.eslintcache
*.lock
yarn-error.log
**/.next/**
**/_next/**
**/dist/**
**/__tmp__/**
lerna.json
.github
/build
.dockerignore
.history
CNAME
Dockerfile*
docker
.editorconfig
.DS_Store



-> jsconfig.json:
{
  "compilerOptions": {
    "baseUrl": ".", // *
    "paths": { 
      "@/*": ["./src/*"] // *
    },
    "outDir": "dist"
  }
  "extends": "../../tsconfig.base.json", // kế thừa cấu hình tránh lặp cấu hình.
  "include": ["src"], // chỉ biên dịch thư mục src
  "files": ["./index.ts"] // đảm bảo file index.ts được biên dịch dù k có trong include
}



-> extendTheme chakra-ui config:
extendTheme({
  semanticTokens: {
    colors: {
      _header: {
        _dark: "#272832",
        default: "#272832",
      },
      background: {
        default: "#fff",
        _dark: "#111827",
      },
      header: {
        default: "#ffff",
        _dark: "#111827f2",
      },
      primary: {
        _dark: "#10a3a3",
        _light: "#3cc9c9",
      },
    },
  },
  colors: {
    white: "#fff",
    black: "#000",
  },
  breakpoints: {
    sm: "30em",
    md: "52em",
    lg: "64em",
    xl: "80em",
  },
  config: {
    initialColorMode: "light",
    useSystemColorMode: false,
  },
  components: {
    Divider: {
      baseStyle: {
        borderColor: "#747474",
      },
    },
  },
});



-> thêm .gitignore:
# dependencies
/node_modules
/.pnp
.pnp.js
# testing
/coverage
# production
/build
# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local
npm-debug.log*
yarn-debug.log*
yarn-error.log*
/.vscode



-> Project structure app router:
public
src
  pages
  app
    api
      hello
        route.js => /api/hello
    dashboard
      layout.js
      loading.js
      not-found.js
      error.js
      template.js
      default.js => fallback nếu k có slot khi cần thế vào layout
      @testslot
        page.js => slots chỉ là 1 phần thế vào layout
      (settings)
        test
          page.js => /dashboard/test
      [slug]
        page.js => /dashboard/a
      [...slug]
        page.js => /dashboard/a/b/c
      [[...settings]]
        page.js => /dashboard/a/b/c và /dashboard
      _settings
        page.js => private toàn folder k routing gì hết 
      (.)settings
        page.js => intercept current route
      (..)settings
        page.js
      (..)(..)folder => intercept 2 cấp
        page.js
      (...)folder => intercept từ root
        page.js
      page.js
      opengraph-image.jsx
      twitter-image.png
      twitter-image.alt.txt
    global-error.js
    favicon.ico
    icon.ico
    apple-icon.png
    sitemap.xml
    robots.txt
  middleware.ts
  instrumentation.ts
  manifest.js
package.json
next.config.js
.env.$(NODE_ENV).local > .env.local > .env.$(NODE_ENV) > .env
jsconfig.json
.eslintrc.json

Cấu trúc code:
<Layout>
  <Template>
    <ErrorBoundary fallback={<Error />}>
      <Suspense fallback={<Loading />}>
        <ErrorBoundary fallback={<NotFound />}>
          <Page />
        </ErrorBoundary>
      </Suspense>
    </ErrorBoundary>
  </Template>
</Layout>

--> sitemap là file chứa các thông tin bổ sung về url kèm lastModified, changeFrequency, priority giúp crawler hiểu hơn về content.
sitemap thường dùng cho các trang có nội dung thường đổi, web lớn phức tạp, đa ngôn ngữ vì sitemap có thể cung thông tin về ngôn ngữ cho mỗi trang giúp crawler hiểu.
sitemap.xml phải tuân thủ:
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
  <url>
    <loc>https://acme.com/about</loc>
    <lastmod>2023-04-06T15:02:24.021Z</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.8</priority>
  </url>
</urlset>
sitemap.ts khi cần generate bằng code chỉ cần export ra 1 hàm return ra object { 
  url: 'https://acme.com/blog',
  lastModified: new Date(),
  changeFrequency: 'weekly',
  priority: 0.5,
}
VD: https://github.com/nodejs/nodejs.org/blob/main/apps/site/app/sitemap.ts => codebase chuẩn cho static site generation



-> Route Segment Config
Hàng loạt các options có thể dùng trong page, layout, route handler: https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config
=> Mịa nó, nó còn dùng export const dynamic = 'error'; ở file sitemap.js để bảo route ở file này dùng static rendering. Ta éo qt mà chỉ dùng cho layout, page, route thôi

- layout.tsx | page.tsx | route.ts:
export const experimental_ppr = true =>*
export const dynamic = 'auto' / 'force-dynamic' / 'error' / 'force-static' => force-dynamic tương đương fetch { cache: 'no-store', next: { revalidate: 0 } }; error sẽ ép page và layout cache và static, nếu dùng dynamic apis sẽ lỗi luôn, tự đổi default của dynamicParams thành false; force-static tương tự nhưng k báo lỗi mà return empty nếu dùng dynamic api, khi có thì route sẽ cache nhiều nhất có thể 
export const dynamicParams = true => vào 1 route mà k được generate với generateStaticParams VD app/posts/[id]/page.js thì false sẽ lỗi 404, true (defautl) sẽ vẫn fetch runtime
export const revalidate = false / number =>*
export const fetchCache = 'auto' / 'default-cache' / 'only-cache' / 'force-cache' / 'force-no-store' / 'default-no-store' / 'only-no-store' 
export const runtime = 'nodejs' / 'edge' => thường dùng edge cho middleware, còn lại render thì dùng nodejs runtime.
export const preferredRegion = 'auto' / 'global' / 'home' / ['iad1', 'sfo1'] 
export const maxDuration = 5 => mặc định nextjs k limit gì cả, set sẽ limit thời gian thực hiện server logics. VD server actions sẽ lỗi timeout nếu quá maxDuration => ít dùng

--> experimental_ppr = true kết hợp ppr: 'incremental' trong next config để enable Partial Prerendering (PPR).
Bth chỉ có static site generation build hoàn toàn ở build time. SSR là server build hoàn toàn ở runtime. Static site increment giống static site generation nhưng có revalidate tự build lại sau 1 ktg. 
Parial Prerendering là việc server vẫn build trước 1 phần tĩnh vào CDN, có request sẽ kết hợp phần động vào hoàn chỉnh.
Dùng trong next: Phải enable option thì mọi component sẽ prerender hết trong lúc build. Các component dynamic cần fetch API cần wrap lại trong Suspense và fallback của Suspense phải là static component để nó prerender luôn.

--> revalidate = false => set giá trị default cho revalidation time của pages, layout, dùng cho router handler thì là thời gian sống của cache lưu data.
Nó là thời gian phải làm mới lại pages, nếu dùng với static site sẽ biến thành static site increment. K dùng được khi dùng runtime = 'edge'
Nó k override revalidate của hàm fetch mà chỉ sửa đổi giá trị default thôi. Khi kích hoạt nó fetch lại cả pages và cả api fetch luôn.
Set là false (default) tương đương Infinity. Set là 0 thì luôn dynamic render lại dù pages k dùng dynamic apis, điều đb là case này sẽ ghi đè nếu fetch dùng force-cache or revalidate (vì nextjs luôn ưu tiên settings k cache). Set là 1 số sẽ đảm bảo endpoint invalidated và re-executed mỗi X phút.
---> Dynamic APIs là sử dụng các hàm cookies, headers, connection, draftMode, searchParams prop

--> fetchCache ít dùng vì nó override default options của hàm fetch trong toàn pages.
Mặc định nextjs cache mọi hàm fetch() gọi trước khi dùng dynamic apis, k cache các hàm fetch() gọi sau dynamic apis.



-> Tổng kết các hàm và file:
route.ts:
import { type NextRequest } from "next/server";
export async function GET(  
  request: Request,
  segmentData: { params: Promise<{ slug: string }> }
) {
  const { slug } = await segmentData.params; // nếu dùng [slug] trong path
  return Response.json({
    data,
  }, {
    status: 200,
    headers: { 
      'Set-Cookie': "name=value" // set cookie 
    }
  });
}
export async function POST(request: NextRequest, context: Context) {
  await request.json();
  return NextResponse.json({ data });
}

layout.tsx | page.tsx:
export const metadata: Metadata = { };
export async function generateMetadata(
  { params, searchParams }: { params: Promise<{ id: string }>, searchParams: Promise<{ [key: string]: string | string[] | undefined }> }, 
  parent: ResolvingMetadata // A promise of the resolved metadata from parent route segments
): Promise<Metadata> { }
export default function Page({ params, searchParams }) {}
export async function generateStaticParams() { // Kết hợp dynamic route để có static route generate ở build time, page k có sẽ generate runtime
  return  [
    { category: 'a', product: '1' },
    { category: 'b', product: '2' },
    { category: 'c', product: '3' },
  ]; // page lấy với const { category, product } = await params
}

icon.tsx | open graph metdata
export function generateImageMetadata({ params }: { params: { slug: string } }) { }

middleware.ts:
import { NextResponse } from "next/server";
export function middleware(req: NextRequest, event: NextFetchEvent) { return NextResponse.next({
  headers: new Headers(req.headers);
}); }
export const config = { matcher: '/' };

Page router:
Page.getInitialProps = async (ctx: NextPageContext) => { => bỏ
  return {};
}
export async function getServerSideProps({ req, res }) {
  return {};
}
export const getStaticProps = (async (context) => {
  return { 
    props: { repo: "" },
    revalidate: 60, // ISR 60s
  }
}) satisfies GetStaticProps<{
  repo: Repo
}>
export const getStaticPaths = (async () => {
  return {};
}) satisfies GetStaticPaths



-> import { cookies, headers, draftMode } from "next/headers"; => server comp
import { unstable_noStores, revalidatePath, revalidateTag } from "next/cache";
import { loadEnvConfig } from "@next/env";
import { redirect, usePathname, useSelectedLayoutSegment, useRouter, useSearchParams } from "next/navigation";
import Link from "next/link";
import Image from "next/image";
import dynamic from "next/dynamic";
import Form from "next/form";
import { connection, after } from "next/server";
import { Inter } from "next/font/google";
import localFont from "next/font/local";
import { PHASE_DEVELOPMENT_SERVER } from "next/constants";

--> const router = useRouter();
router.push(`/demo?count={count + 1}`, { 
  scroll: false, // Prevent scrolling to top
  shallow: true, // Đổi url mà k navigate, có thể dùng window.history.pushState được
  state: { // truyền custom state lấy qua window.history.state
    someData: 'custom data'
  }
})
router.push({ => cách khác truyền 1 object duy nhất
  pathname: '/destination',
  query: {
    id: '123',
    category: 'example'
  }
})
router.replace('/new-route', {
  query: {
    q: 'nextjs',
    page: '2'
  },
  scroll: false, // Prevent scrolling
  state: { // truyền custom state lấy qua window.history.state
    replacement: true, // Custom state
  }
})

--> <Form
  action="/search" => string sẽ navigate client side, prefetch, hàm thì là server actions
  replace={false} => true sẽ replace route k thể back về
  scroll={true} => default true sẽ luôn scroll lên top của new route
  prefetch={true} => default true sẽ prefetch khi visible trên viewport.
  onSubmit={(e) => {e.preventDefault();}} 
>
  <input type="submit"
    formAction="/test" // override action của <Form> y hệt nhưng k prefetch
  ></input>
</Form>

--> <Image
  src="/profile.png"
  style={{objectFit: "contain"}}
  width={500}
  height={500}
  fill={true} => fill thẻ cha, thì k cần truyền width height cũng được
  alt="Picture of the author"
  priority={true} => ưu tiên tải ngay lập tức 
  loading="lazy" => trì hoãn tải cho đến khi xuất hiện trong viewport
  blurDataURL="data:image/jpeg..." => nếu ảnh là local image, sẽ tự có blur url do nextjs optimize mà k cần điền => có tự éo đâu
  placeholder="empty" => empty default kcj, "blur" sẽ dùng ảnh của blurDataURL, hoặc truyền ảnh blur trực tiếp base64 "data:image/..." 
  onError={(e) => console.error(e.target.id)}
  sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw" => dùng như srcset
/>

--> <Link 
  href="/dashboard"
  replace={true} => replace k thể back lại
  prefetch={true} => null (default) thì chỉ refetch static route và partial route gần nhất của dynamic route, true thì prefetch hết
  scroll={true} => default true sẽ giữ vị trí scroll khi mà Page hiện tại bằng cách nào đó ấn Link mà vẫn hiện trên màn hình
/>



-> fetch(url, {
  cache: "no-store", // "force-cache"
  next: {
    revalidate: 3600, // > 3600s sau khi vào sẽ thấy page vẫn cũ nhưng trigger revalidate, reload lần nữa sẽ thấy data mới
    tags: ["a", "b"],
  },
}) 

