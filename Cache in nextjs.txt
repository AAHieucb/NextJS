# Tổng quan caching trong App Router
Nếu client gửi duplicate request trong 1 pass, nextjs sẽ memoize chỉ gọi 1 lần -> Gửi request đi lại có Client-side Router Cache ở ngay client -> Tới server có Full Route Cache có sẵn html từ request trước đó không -> Nếu không, server check Data Cache lưu JSON data của API chưa -> Chưa có mới call api.
Hàng loạt example: https://nextjs.org/docs/app/building-your-application/data-fetching/fetching

- Cache trong nextjs lưu trong filesystem của server. Server khác nhau có cache system khác nhau. Có thể config tuỳ ý sang 1 storage bền vững như redis và chia sẻ chung.
- Nếu dùng fetch force-cache sẽ cache ngay từ build time (pre-rendering). 
Nếu k muốn cache thì dùng export dynamic = "force-dynamic" trong page, hoặc dùng option no-store (default), hoặc option revalidate = 0 của fetch, hoặc tương đương với export const fetchCache = 'force-no-store' (ghi đè tất cả)



# Browser có sẵn cache
Browser tự cache request theo trường Cache-Control trong response header. VD set là max-age=10 sẽ cache trong 10s => Ta thường k đụng vì các framework default tự cache static file css js html img, dynamic part thì k cache.
Bản chất khi disable cache của browser hoặc hard reload lại k dùng cache thì sẽ chỉnh sửa header và đè lên setting của server nextjs vì server nextjs cũng theo config đó => Kqt vì bth luôn để có cache.

-> Nextjs tự thêm Cache-Control cho truly immutable assets là "public, max-age=31536000, immutable", bao gồm static image và điều này k thể đổi, cx k cần đổi.
Riêng với image, có thể config minimumCacheTTL, deviceSizes, imageSizes, formats. 
Khi có cả 2 minimumCacheTTL và Cache-Control sẽ chọn cái có time lớn hơn, nên k thể ép thời gian cache image nhỏ hơn setting fix của Cache-Control được
Các page dynamic cũng tự set Cache-Control cho browser là "private, no-cache, no-store, max-age=0, must-revalidate" để k dùng browser cache.

=>*** Chốt: cái này k cần đụng, mặc định cache các file assets static kệ nó thôi.



# Request Memoization
Fetch của NextJS tự động cache request call trong 1 single render pass ở server side, hết pass sẽ xoá đi. Vd call API bằng fetch của nextjs như Promise.all([fetchData(), fetchData()]) tới server sẽ thấy chỉ gọi 1 lần.
Nó chỉ có sẵn ở fetch của server side nextjs, còn client side thì vẫn request lại nhiều lần, phải tự custom xử lý mới fix deduplicate phía client được.

Chỉ cần dùng fetch có sẵn của nextjs là tự có request memoization r. Thực tế đây là tính năng của React có sẵn, NextJS chỉ override lại hàm fetch với nó. Nếu gọi db, CMS client, GraphQL k dùng được fetch thì có thể tự dùng cache của React để có Request Memoization. Chú ý là cache này nằm phía server.
VD: import { cache } from 'react'; const fetchWithCache = cache( async (url) => { const res = await fetch(url); return res.json(); }); => nextjs dùng v ok luôn
Các thư viện như swr, react-query cũng giúp sẵn tạo Request Memoization tự cache request, xử lý deduplicate trong ktg ngắn.
Trong nextjs còn có { unstable_cache } hỗ trợ request memoization và mặc định nó cache mãi y hệt "force-cache" => éo bh dùng.

=>*** Chốt: cứ dùng fetch GET sẽ tự request memoization cho 1 single render pass r, với kiểu khác hoặc call ở client thì luôn wrap bằng cache của react là xong. VD middleware gọi, trong page client lại gọi thì chỉ gọi 1 lần



# Client-side Router Cache
Cache đầu tiên cản request làm thêm bất cứ thứ gì, sẽ k gọi api đi nữa. App Router có cache này có thể khiến navigate giữa các page k call gì vào server hết.
URL: https://nextjs.org/docs/app/api-reference/next-config-js/staleTimes

-> Bản chất nó cache RSC payload ở client. Đó là kết quả render từ server kèm cả data để client tự show ra luôn.
VD ta navigate sang route khác rồi quay về route này thì có sẵn cache RCS route này rồi, show ra html kèm data luôn.
VD ta call 1 api, rồi call lại api đó lần 2 ở server, sẽ k dùng client-side router cache. Nó chỉ cache RSC khi navigate các page.
Trong browser có sẵn 1 loại cache khác khá giống là bfcache. Khi navigate tiến lùi thì browser sẽ tự cache page đó serve tức thì. bfcache klq tới Client-side Router Cache.

-> Kiểm soát cache:
Mặc định tự có client-side router cache không có cho page.js. Còn layout.js và loading.js mặc định có theo 2 case:
- Nếu prefetch={null} or kxđ thì k cache dynamic pages, 5m cho static pages.
- prefetch={true} hoặc dùng router.prefetch thì 5m cho cả static và dynamic pages.
Có thể opt-in cache cho cả page.js với config { staleTimes: { dynamic: 30 } }, khi đó cả page.js, loading.js và layout.js đều theo setting đó => SSG ngay client

-> Để invalidate: 
Reload page
Dùng router.refresh phía client, nó prerender cả client và server, chỉ là client preserve state thôi, nhưng Router Cache cũng bị validate
Dùng revalidatePath revalidateTag cho server action sẽ invalidate Router Cache ở client luôn

=>*** Chốt: 
Để mặc định là đã có cache loading.js và layout.js ở client cho static page rồi => để mặc định ok
Muốn cho cả dynamic page thì chỉ rõ prefetch={true} => nếu cần prefetch dynamic page thì set
Muốn cache cả page.js thì thêm config config { staleTimes: { dynamic: 30 } } => ít dùng vì SSG



# Full Route Cache
Cache ở server, nếu page đã từng render html sẽ hiện luôn. Khác với Data Cache chỉ cache api data, full route cache trên server api data và html đã render, cản server làm bất cứ thứ gì như call api và render lại html.

-> Cơ chế server xử lý render:
- Khi server render, data chia thành chunks là các phần routes khác nhau. 
- Mỗi chunk qua 2 bước là render server component thành dạng React Server Component Payload (RSC payload), rồi kết hợp pre-render Client Component để render ra html hoàn chỉnh trên server
- HTML hoàn chỉnh từ server hiện ra ngay và k thể tương tác, vì server component chả có JS gì mà tương tác, còn client component thì chưa hydrate -> sau khi browser tải file js và hydrate client component xong thì tương tác được.

-> Kiểm soát cache:
Mặc định static routes được cache lúc build và có luôn ở lần truy cập đầu tiên. Nếu revalidate xong, nó sẽ cache ở lần truy cập sau.
Mặc định dynamic route sẽ k cache lúc build mà chỉ cache ở lần truy cập đầu tiên.

-> Để invalidate:
Redeploy sẽ invalidate full route cache, mà k invalidate Data Cache.
Invalidate data cache sẽ invalidate full route cache. VD cho hàm fetch bị revalidate, no-store để opt-out luôn.

=>*** Chốt: Chỉ cần qt data cache, vì full route cache dùng api data từ data cache mà. Data cache k đổi thì RSC payload k đổi thì full route cache vẫn thế.



# Data Cache
Thứ tự: Client Side Cache HTML -> Full Router Cache HTML -> Data Cache API
Request Memoization chỉ xét tới 1 lần render, còn Data Cache xét toàn bộ dự án ở phía server
Lưu ý Cache-Control header quản lý browser cache, cache này sẽ override cache của hàm fetch nextjs. VD disable cache và reload trên browser sẽ luôn call lại ở server => ta kqt vì browser production sẽ enable cache

-> Kiểm soát cache:
VD option hàm fetch:
fetch('https://...', { cache: "no-store }) => default behavior, SSR dynamic
fetch('https://...', { cache: "force-cache" }) => luôn cache, static site
fetch('https://...', { next: { revalidate: 3600 } }) => time-based revalidate, SSG
fetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } }) => gọi revalidateTag('a') để revalidate cache chứa tag cụ thể
revalidatePath("/") => rerender và refetch lại hết api trên 1 route

VD dùng segment config:
export const fetchCache = 'default-cache' => khiến mọi fetch request ở page đó default đều được cached, k dùng vì override setting của hàm fetch
export const dynamic = 'force-dynamic' => khiến mọi request đều call lại = default = { cache: 'no-store' } = { next: { revalidate: 0 } }

VD: import { unstable_noStores } from "next/cache"; y hệt option cache:"no-store", có option revalidate luôn => thay bằng await connection() r, sẽ luôn fetch lại

=>*** Chốt: chỉ cần qt các options của fetch để cache, SSG hay dynamic. Có export force-dynamic cũng khiến luôn call lại api.



# dynamicIO và "use cache"
Nhiều lúc cần call async function sinh data động nhưng k dùng fetch, nextjs không hiẻu mà tưởng nó là static pages. Trên bản production sẽ chạy qua async 1 lần sinh data fix cứng luôn. Khi đó buộc ta phải thêm await connection để thành pages dynamic (enable partial rendering).
*** Khi call hàm async, nên tách riêng component và cho vào Suspense thì mọi thứ được load ngay lập tức. Nếu call async k tách riêng comp mà viết chung vào page k có Suspense thì cả pages sẽ bị lag chờ api thực hiện xong cơ.

Giải pháp khác là dùng dynamicIO sẽ đổi default:
dynamicIO là options config khiến cho page luôn là dynamic miễn là có bất cứ hàm async nào được gọi trong page đó, đồng thời opt-out hét mọi cache.
Khi app ở chế độ dynamicIO, mọi call async phải wrap trong Suspense hoặc dùng "use cache", kể cả await searchParams.
URL: https://www.youtube.com/watch?v=nHnw3pusFXw => dừng ở "use cache basics"
